// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ListRelationshipOptions list relationship options
//
// swagger:model ListRelationshipOptions
type ListRelationshipOptions struct {

	// affiliated group inactive
	AffiliatedGroupInactive bool `json:"AffiliatedGroupInactive,omitempty"`

	// affiliated group list
	AffiliatedGroupList *ListSummary `json:"AffiliatedGroupList,omitempty"`

	// affiliated group types
	AffiliatedGroupTypes string `json:"AffiliatedGroupTypes,omitempty"`

	// affiliated group use dates
	AffiliatedGroupUseDates bool `json:"AffiliatedGroupUseDates,omitempty"`

	// affiliated individual inactive
	AffiliatedIndividualInactive bool `json:"AffiliatedIndividualInactive,omitempty"`

	// affiliated individual list
	AffiliatedIndividualList *ListSummary `json:"AffiliatedIndividualList,omitempty"`

	// affiliated individual types
	AffiliatedIndividualTypes string `json:"AffiliatedIndividualTypes,omitempty"`

	// affiliated individual use dates
	AffiliatedIndividualUseDates bool `json:"AffiliatedIndividualUseDates,omitempty"`

	// associated inactive
	AssociatedInactive bool `json:"AssociatedInactive,omitempty"`

	// associated list
	AssociatedList *ListSummary `json:"AssociatedList,omitempty"`

	// associated types
	AssociatedTypes string `json:"AssociatedTypes,omitempty"`

	// associated use dates
	AssociatedUseDates bool `json:"AssociatedUseDates,omitempty"`

	// create location
	CreateLocation string `json:"CreateLocation,omitempty"`

	// created by
	CreatedBy string `json:"CreatedBy,omitempty"`

	// created date time
	// Format: date-time
	CreatedDateTime strfmt.DateTime `json:"CreatedDateTime,omitempty"`

	// keep or replace original
	KeepOrReplaceOriginal string `json:"KeepOrReplaceOriginal,omitempty"`

	// replace individuals
	ReplaceIndividuals string `json:"ReplaceIndividuals,omitempty"`

	// updated by
	UpdatedBy string `json:"UpdatedBy,omitempty"`

	// updated date time
	// Format: date-time
	UpdatedDateTime strfmt.DateTime `json:"UpdatedDateTime,omitempty"`
}

// Validate validates this list relationship options
func (m *ListRelationshipOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAffiliatedGroupList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAffiliatedIndividualList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAssociatedList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedDateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ListRelationshipOptions) validateAffiliatedGroupList(formats strfmt.Registry) error {
	if swag.IsZero(m.AffiliatedGroupList) { // not required
		return nil
	}

	if m.AffiliatedGroupList != nil {
		if err := m.AffiliatedGroupList.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("AffiliatedGroupList")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("AffiliatedGroupList")
			}
			return err
		}
	}

	return nil
}

func (m *ListRelationshipOptions) validateAffiliatedIndividualList(formats strfmt.Registry) error {
	if swag.IsZero(m.AffiliatedIndividualList) { // not required
		return nil
	}

	if m.AffiliatedIndividualList != nil {
		if err := m.AffiliatedIndividualList.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("AffiliatedIndividualList")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("AffiliatedIndividualList")
			}
			return err
		}
	}

	return nil
}

func (m *ListRelationshipOptions) validateAssociatedList(formats strfmt.Registry) error {
	if swag.IsZero(m.AssociatedList) { // not required
		return nil
	}

	if m.AssociatedList != nil {
		if err := m.AssociatedList.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("AssociatedList")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("AssociatedList")
			}
			return err
		}
	}

	return nil
}

func (m *ListRelationshipOptions) validateCreatedDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("CreatedDateTime", "body", "date-time", m.CreatedDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ListRelationshipOptions) validateUpdatedDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdatedDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("UpdatedDateTime", "body", "date-time", m.UpdatedDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this list relationship options based on the context it is used
func (m *ListRelationshipOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAffiliatedGroupList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAffiliatedIndividualList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAssociatedList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ListRelationshipOptions) contextValidateAffiliatedGroupList(ctx context.Context, formats strfmt.Registry) error {

	if m.AffiliatedGroupList != nil {

		if swag.IsZero(m.AffiliatedGroupList) { // not required
			return nil
		}

		if err := m.AffiliatedGroupList.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("AffiliatedGroupList")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("AffiliatedGroupList")
			}
			return err
		}
	}

	return nil
}

func (m *ListRelationshipOptions) contextValidateAffiliatedIndividualList(ctx context.Context, formats strfmt.Registry) error {

	if m.AffiliatedIndividualList != nil {

		if swag.IsZero(m.AffiliatedIndividualList) { // not required
			return nil
		}

		if err := m.AffiliatedIndividualList.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("AffiliatedIndividualList")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("AffiliatedIndividualList")
			}
			return err
		}
	}

	return nil
}

func (m *ListRelationshipOptions) contextValidateAssociatedList(ctx context.Context, formats strfmt.Registry) error {

	if m.AssociatedList != nil {

		if swag.IsZero(m.AssociatedList) { // not required
			return nil
		}

		if err := m.AssociatedList.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("AssociatedList")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("AssociatedList")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ListRelationshipOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ListRelationshipOptions) UnmarshalBinary(b []byte) error {
	var res ListRelationshipOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
