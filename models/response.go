// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Response response
//
// swagger:model Response
type Response struct {

	// error messages
	ErrorMessages []*ErrorMessage `json:"ErrorMessages"`

	// request Id
	RequestID int32 `json:"RequestId,omitempty"`

	// response object
	ResponseObject interface{} `json:"ResponseObject,omitempty"`

	// status code
	// Enum: [100 101 200 201 202 203 204 205 206 300 300 301 301 302 302 303 303 304 305 306 307 307 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 426 500 501 502 503 504 505]
	StatusCode int32 `json:"StatusCode,omitempty"`
}

// Validate validates this response
func (m *Response) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateErrorMessages(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatusCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Response) validateErrorMessages(formats strfmt.Registry) error {
	if swag.IsZero(m.ErrorMessages) { // not required
		return nil
	}

	for i := 0; i < len(m.ErrorMessages); i++ {
		if swag.IsZero(m.ErrorMessages[i]) { // not required
			continue
		}

		if m.ErrorMessages[i] != nil {
			if err := m.ErrorMessages[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ErrorMessages" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ErrorMessages" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var responseTypeStatusCodePropEnum []interface{}

func init() {
	var res []int32
	if err := json.Unmarshal([]byte(`[100,101,200,201,202,203,204,205,206,300,300,301,301,302,302,303,303,304,305,306,307,307,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,426,500,501,502,503,504,505]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		responseTypeStatusCodePropEnum = append(responseTypeStatusCodePropEnum, v)
	}
}

// prop value enum
func (m *Response) validateStatusCodeEnum(path, location string, value int32) error {
	if err := validate.EnumCase(path, location, value, responseTypeStatusCodePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Response) validateStatusCode(formats strfmt.Registry) error {
	if swag.IsZero(m.StatusCode) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusCodeEnum("StatusCode", "body", m.StatusCode); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this response based on the context it is used
func (m *Response) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateErrorMessages(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Response) contextValidateErrorMessages(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ErrorMessages); i++ {

		if m.ErrorMessages[i] != nil {

			if swag.IsZero(m.ErrorMessages[i]) { // not required
				return nil
			}

			if err := m.ErrorMessages[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ErrorMessages" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ErrorMessages" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Response) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Response) UnmarshalBinary(b []byte) error {
	var res Response
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
