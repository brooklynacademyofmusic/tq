// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Payment payment
//
// swagger:model Payment
type Payment struct {

	// account number
	AccountNumber string `json:"AccountNumber,omitempty"`

	// authorization indicator
	AuthorizationIndicator string `json:"AuthorizationIndicator,omitempty"`

	// authorization number
	AuthorizationNumber string `json:"AuthorizationNumber,omitempty"`

	// batch Id
	BatchID int32 `json:"BatchId,omitempty"`

	// c c issue number
	CCIssueNumber string `json:"CCIssueNumber,omitempty"`

	// c c reference number
	CCReferenceNumber string `json:"CCReferenceNumber,omitempty"`

	// c c start date time
	CCStartDateTime string `json:"CCStartDateTime,omitempty"`

	// card expiry date time
	// Format: date-time
	CardExpiryDateTime strfmt.DateTime `json:"CardExpiryDateTime,omitempty"`

	// check name
	CheckName string `json:"CheckName,omitempty"`

	// check number
	CheckNumber string `json:"CheckNumber,omitempty"`

	// constituent
	Constituent *Entity `json:"Constituent,omitempty"`

	// created by
	CreatedBy string `json:"CreatedBy,omitempty"`

	// created date time
	// Format: date-time
	CreatedDateTime strfmt.DateTime `json:"CreatedDateTime,omitempty"`

	// gift certificate
	GiftCertificate *GiftCertificateSummary `json:"GiftCertificate,omitempty"`

	// Id
	ID int32 `json:"Id,omitempty"`

	// is mirror record
	IsMirrorRecord bool `json:"IsMirrorRecord,omitempty"`

	// notes
	Notes string `json:"Notes,omitempty"`

	// payment amount
	PaymentAmount float64 `json:"PaymentAmount,omitempty"`

	// payment date time
	// Format: date-time
	PaymentDateTime strfmt.DateTime `json:"PaymentDateTime,omitempty"`

	// payment method
	PaymentMethod *PaymentMethod `json:"PaymentMethod,omitempty"`

	// payment signature Id
	PaymentSignatureID int32 `json:"PaymentSignatureId,omitempty"`

	// refund date time
	// Format: date-time
	RefundDateTime strfmt.DateTime `json:"RefundDateTime,omitempty"`

	// tendered amount
	TenderedAmount float64 `json:"TenderedAmount,omitempty"`

	// transaction Id
	TransactionID int32 `json:"TransactionId,omitempty"`
}

// Validate validates this payment
func (m *Payment) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCardExpiryDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConstituent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGiftCertificate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymentDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymentMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRefundDateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Payment) validateCardExpiryDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.CardExpiryDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("CardExpiryDateTime", "body", "date-time", m.CardExpiryDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateConstituent(formats strfmt.Registry) error {
	if swag.IsZero(m.Constituent) { // not required
		return nil
	}

	if m.Constituent != nil {
		if err := m.Constituent.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Constituent")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("Constituent")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateCreatedDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("CreatedDateTime", "body", "date-time", m.CreatedDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateGiftCertificate(formats strfmt.Registry) error {
	if swag.IsZero(m.GiftCertificate) { // not required
		return nil
	}

	if m.GiftCertificate != nil {
		if err := m.GiftCertificate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("GiftCertificate")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("GiftCertificate")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validatePaymentDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.PaymentDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("PaymentDateTime", "body", "date-time", m.PaymentDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validatePaymentMethod(formats strfmt.Registry) error {
	if swag.IsZero(m.PaymentMethod) { // not required
		return nil
	}

	if m.PaymentMethod != nil {
		if err := m.PaymentMethod.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("PaymentMethod")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("PaymentMethod")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateRefundDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.RefundDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("RefundDateTime", "body", "date-time", m.RefundDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this payment based on the context it is used
func (m *Payment) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateConstituent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGiftCertificate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePaymentMethod(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Payment) contextValidateConstituent(ctx context.Context, formats strfmt.Registry) error {

	if m.Constituent != nil {

		if swag.IsZero(m.Constituent) { // not required
			return nil
		}

		if err := m.Constituent.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Constituent")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("Constituent")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) contextValidateGiftCertificate(ctx context.Context, formats strfmt.Registry) error {

	if m.GiftCertificate != nil {

		if swag.IsZero(m.GiftCertificate) { // not required
			return nil
		}

		if err := m.GiftCertificate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("GiftCertificate")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("GiftCertificate")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) contextValidatePaymentMethod(ctx context.Context, formats strfmt.Registry) error {

	if m.PaymentMethod != nil {

		if swag.IsZero(m.PaymentMethod) { // not required
			return nil
		}

		if err := m.PaymentMethod.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("PaymentMethod")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("PaymentMethod")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Payment) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Payment) UnmarshalBinary(b []byte) error {
	var res Payment
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
