// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// InvoiceBillingRequest invoice billing request
//
// swagger:model InvoiceBillingRequest
type InvoiceBillingRequest struct {

	// appeal Id
	AppealID int32 `json:"AppealId,omitempty"`

	// batch type Id
	BatchTypeID int32 `json:"BatchTypeId,omitempty"`

	// billing type Id
	BillingTypeID int32 `json:"BillingTypeId,omitempty"`

	// business unit Id
	BusinessUnitID int32 `json:"BusinessUnitId,omitempty"`

	// cutoff date time
	// Format: date-time
	CutoffDateTime strfmt.DateTime `json:"CutoffDateTime,omitempty"`

	// electronic address purpose Id
	ElectronicAddressPurposeID int32 `json:"ElectronicAddressPurposeId,omitempty"`

	// electronic address type Id
	ElectronicAddressTypeID int32 `json:"ElectronicAddressTypeId,omitempty"`

	// end date time
	// Format: date-time
	EndDateTime strfmt.DateTime `json:"EndDateTime,omitempty"`

	// invoice end date time
	// Format: date-time
	InvoiceEndDateTime strfmt.DateTime `json:"InvoiceEndDateTime,omitempty"`

	// invoice start date time
	// Format: date-time
	InvoiceStartDateTime strfmt.DateTime `json:"InvoiceStartDateTime,omitempty"`

	// is label
	IsLabel bool `json:"IsLabel,omitempty"`

	// list Id
	ListID int32 `json:"ListId,omitempty"`

	// mail date time
	// Format: date-time
	MailDateTime strfmt.DateTime `json:"MailDateTime,omitempty"`

	// mail type Id
	MailTypeID int32 `json:"MailTypeId,omitempty"`

	// max number of bills to print
	MaxNumberOfBillsToPrint int32 `json:"MaxNumberOfBillsToPrint,omitempty"`

	// media type Id
	MediaTypeID int32 `json:"MediaTypeId,omitempty"`

	// min amount
	MinAmount float64 `json:"MinAmount,omitempty"`

	// min number of bills to print
	MinNumberOfBillsToPrint int32 `json:"MinNumberOfBillsToPrint,omitempty"`

	// new source description
	NewSourceDescription string `json:"NewSourceDescription,omitempty"`

	// payment method group Id
	PaymentMethodGroupID int32 `json:"PaymentMethodGroupId,omitempty"`

	// payment method Id
	PaymentMethodID int32 `json:"PaymentMethodId,omitempty"`

	// respect electronic address marketing flag
	RespectElectronicAddressMarketingFlag bool `json:"RespectElectronicAddressMarketingFlag,omitempty"`

	// salutation type Id
	SalutationTypeID int32 `json:"SalutationTypeId,omitempty"`

	// should collect all
	ShouldCollectAll bool `json:"ShouldCollectAll,omitempty"`

	// should update
	ShouldUpdate bool `json:"ShouldUpdate,omitempty"`

	// start date time
	// Format: date-time
	StartDateTime strfmt.DateTime `json:"StartDateTime,omitempty"`

	// user Id
	UserID string `json:"UserId,omitempty"`
}

// Validate validates this invoice billing request
func (m *InvoiceBillingRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCutoffDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInvoiceEndDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInvoiceStartDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMailDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartDateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *InvoiceBillingRequest) validateCutoffDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.CutoffDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("CutoffDateTime", "body", "date-time", m.CutoffDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *InvoiceBillingRequest) validateEndDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.EndDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("EndDateTime", "body", "date-time", m.EndDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *InvoiceBillingRequest) validateInvoiceEndDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.InvoiceEndDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("InvoiceEndDateTime", "body", "date-time", m.InvoiceEndDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *InvoiceBillingRequest) validateInvoiceStartDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.InvoiceStartDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("InvoiceStartDateTime", "body", "date-time", m.InvoiceStartDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *InvoiceBillingRequest) validateMailDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.MailDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("MailDateTime", "body", "date-time", m.MailDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *InvoiceBillingRequest) validateStartDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.StartDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("StartDateTime", "body", "date-time", m.StartDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this invoice billing request based on context it is used
func (m *InvoiceBillingRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *InvoiceBillingRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *InvoiceBillingRequest) UnmarshalBinary(b []byte) error {
	var res InvoiceBillingRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
