// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// OrderBillingRequest order billing request
//
// swagger:model OrderBillingRequest
type OrderBillingRequest struct {

	// appeal Id
	AppealID int32 `json:"AppealId,omitempty"`

	// batch type Id
	BatchTypeID int32 `json:"BatchTypeId,omitempty"`

	// billing type Id
	BillingTypeID int32 `json:"BillingTypeId,omitempty"`

	// cutoff date time
	// Format: date-time
	CutoffDateTime *strfmt.DateTime `json:"CutoffDateTime,omitempty"`

	// end date time
	// Format: date-time
	EndDateTime *strfmt.DateTime `json:"EndDateTime,omitempty"`

	// list Id
	ListID int32 `json:"ListId,omitempty"`

	// max number of bills to print
	MaxNumberOfBillsToPrint int32 `json:"MaxNumberOfBillsToPrint,omitempty"`

	// media type Id
	MediaTypeID int32 `json:"MediaTypeId,omitempty"`

	// min amount
	MinAmount float64 `json:"MinAmount,omitempty"`

	// min number of bills to print
	MinNumberOfBillsToPrint int32 `json:"MinNumberOfBillsToPrint,omitempty"`

	// modes of sale
	ModesOfSale string `json:"ModesOfSale,omitempty"`

	// new source description
	NewSourceDescription string `json:"NewSourceDescription,omitempty"`

	// order end date time
	// Format: date-time
	OrderEndDateTime *strfmt.DateTime `json:"OrderEndDateTime,omitempty"`

	// order start date time
	// Format: date-time
	OrderStartDateTime *strfmt.DateTime `json:"OrderStartDateTime,omitempty"`

	// payment method group Id
	PaymentMethodGroupID int32 `json:"PaymentMethodGroupId,omitempty"`

	// performance end date time
	// Format: date-time
	PerformanceEndDateTime *strfmt.DateTime `json:"PerformanceEndDateTime,omitempty"`

	// performance start date time
	// Format: date-time
	PerformanceStartDateTime *strfmt.DateTime `json:"PerformanceStartDateTime,omitempty"`

	// seasons
	Seasons string `json:"Seasons,omitempty"`

	// should update
	ShouldUpdate bool `json:"ShouldUpdate,omitempty"`

	// start date time
	// Format: date-time
	StartDateTime *strfmt.DateTime `json:"StartDateTime,omitempty"`

	// user Id
	UserID string `json:"UserId,omitempty"`
}

// Validate validates this order billing request
func (m *OrderBillingRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCutoffDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderEndDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderStartDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePerformanceEndDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePerformanceStartDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartDateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OrderBillingRequest) validateCutoffDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.CutoffDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("CutoffDateTime", "body", "date-time", m.CutoffDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OrderBillingRequest) validateEndDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.EndDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("EndDateTime", "body", "date-time", m.EndDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OrderBillingRequest) validateOrderEndDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.OrderEndDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("OrderEndDateTime", "body", "date-time", m.OrderEndDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OrderBillingRequest) validateOrderStartDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.OrderStartDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("OrderStartDateTime", "body", "date-time", m.OrderStartDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OrderBillingRequest) validatePerformanceEndDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.PerformanceEndDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("PerformanceEndDateTime", "body", "date-time", m.PerformanceEndDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OrderBillingRequest) validatePerformanceStartDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.PerformanceStartDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("PerformanceStartDateTime", "body", "date-time", m.PerformanceStartDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OrderBillingRequest) validateStartDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.StartDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("StartDateTime", "body", "date-time", m.StartDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this order billing request based on context it is used
func (m *OrderBillingRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *OrderBillingRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OrderBillingRequest) UnmarshalBinary(b []byte) error {
	var res OrderBillingRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
