// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ProductSearchRequest product search request
//
// swagger:model ProductSearchRequest
type ProductSearchRequest struct {

	// artist Id
	ArtistID int32 `json:"ArtistId,omitempty"`

	// business unit Id
	BusinessUnitID int32 `json:"BusinessUnitId,omitempty"`

	// composer Id
	ComposerID int32 `json:"ComposerId,omitempty"`

	// constituent Id
	ConstituentID int32 `json:"ConstituentId,omitempty"`

	// day of week
	DayOfWeek string `json:"DayOfWeek,omitempty"`

	// end date range
	// Format: date-time
	EndDateRange *strfmt.DateTime `json:"EndDateRange,omitempty"`

	// end date range package
	// Format: date-time
	EndDateRangePackage *strfmt.DateTime `json:"EndDateRangePackage,omitempty"`

	// facility Id
	FacilityID int32 `json:"FacilityId,omitempty"`

	// full text
	FullText string `json:"FullText,omitempty"`

	// full text type
	FullTextType string `json:"FullTextType,omitempty"`

	// is web search
	IsWebSearch bool `json:"IsWebSearch,omitempty"`

	// keyword and or
	KeywordAndOr int32 `json:"KeywordAndOr,omitempty"`

	// keyword descriptions
	KeywordDescriptions string `json:"KeywordDescriptions,omitempty"`

	// keyword Id
	KeywordID int32 `json:"KeywordId,omitempty"`

	// keywords
	Keywords string `json:"Keywords,omitempty"`

	// language Id
	LanguageID int32 `json:"LanguageId,omitempty"`

	// mode of sale Id
	ModeOfSaleID int32 `json:"ModeOfSaleId,omitempty"`

	// on sale only
	OnSaleOnly bool `json:"OnSaleOnly,omitempty"`

	// one or all performances in package
	OneOrAllPerformancesInPackage string `json:"OneOrAllPerformancesInPackage,omitempty"`

	// package Id
	PackageID int32 `json:"PackageId,omitempty"`

	// package ids
	PackageIds string `json:"PackageIds,omitempty"`

	// package season Id
	PackageSeasonID int32 `json:"PackageSeasonId,omitempty"`

	// package type Id
	PackageTypeID int32 `json:"PackageTypeId,omitempty"`

	// performance ids
	PerformanceIds string `json:"PerformanceIds,omitempty"`

	// production season Id
	ProductionSeasonID int32 `json:"ProductionSeasonId,omitempty"`

	// production season ids
	ProductionSeasonIds string `json:"ProductionSeasonIds,omitempty"`

	// season Id
	SeasonID int32 `json:"SeasonId,omitempty"`

	// season ids
	SeasonIds string `json:"SeasonIds,omitempty"`

	// show all
	ShowAll bool `json:"ShowAll,omitempty"`

	// show constituent availability
	ShowConstituentAvailability bool `json:"ShowConstituentAvailability,omitempty"`

	// show gross availability
	ShowGrossAvailability bool `json:"ShowGrossAvailability,omitempty"`

	// start date range
	// Format: date-time
	StartDateRange *strfmt.DateTime `json:"StartDateRange,omitempty"`

	// start date range package
	// Format: date-time
	StartDateRangePackage *strfmt.DateTime `json:"StartDateRangePackage,omitempty"`

	// time slot Id
	TimeSlotID int32 `json:"TimeSlotId,omitempty"`

	// title Id
	TitleID int32 `json:"TitleId,omitempty"`
}

// Validate validates this product search request
func (m *ProductSearchRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEndDateRange(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndDateRangePackage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartDateRange(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartDateRangePackage(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProductSearchRequest) validateEndDateRange(formats strfmt.Registry) error {
	if swag.IsZero(m.EndDateRange) { // not required
		return nil
	}

	if err := validate.FormatOf("EndDateRange", "body", "date-time", m.EndDateRange.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ProductSearchRequest) validateEndDateRangePackage(formats strfmt.Registry) error {
	if swag.IsZero(m.EndDateRangePackage) { // not required
		return nil
	}

	if err := validate.FormatOf("EndDateRangePackage", "body", "date-time", m.EndDateRangePackage.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ProductSearchRequest) validateStartDateRange(formats strfmt.Registry) error {
	if swag.IsZero(m.StartDateRange) { // not required
		return nil
	}

	if err := validate.FormatOf("StartDateRange", "body", "date-time", m.StartDateRange.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ProductSearchRequest) validateStartDateRangePackage(formats strfmt.Registry) error {
	if swag.IsZero(m.StartDateRangePackage) { // not required
		return nil
	}

	if err := validate.FormatOf("StartDateRangePackage", "body", "date-time", m.StartDateRangePackage.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this product search request based on context it is used
func (m *ProductSearchRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ProductSearchRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProductSearchRequest) UnmarshalBinary(b []byte) error {
	var res ProductSearchRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
