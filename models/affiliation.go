// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Affiliation affiliation
//
// swagger:model Affiliation
type Affiliation struct {

	// address Id
	AddressID int32 `json:"AddressId,omitempty"`

	// affiliated name
	AffiliatedName string `json:"AffiliatedName,omitempty"`

	// affiliation type
	AffiliationType *AffiliationTypeSummary `json:"AffiliationType,omitempty"`

	// create location
	CreateLocation string `json:"CreateLocation,omitempty"`

	// created by
	CreatedBy string `json:"CreatedBy,omitempty"`

	// created date time
	// Format: date-time
	CreatedDateTime *strfmt.DateTime `json:"CreatedDateTime,omitempty"`

	// edit indicator
	EditIndicator bool `json:"EditIndicator,omitempty"`

	// electronic address Id
	ElectronicAddressID int32 `json:"ElectronicAddressId,omitempty"`

	// end date
	// Format: date-time
	EndDate *strfmt.DateTime `json:"EndDate,omitempty"`

	// group constituent
	GroupConstituent *Entity `json:"GroupConstituent,omitempty"`

	// group constituent name
	GroupConstituentName string `json:"GroupConstituentName,omitempty"`

	// group constituent sort name
	GroupConstituentSortName string `json:"GroupConstituentSortName,omitempty"`

	// Id
	ID int32 `json:"Id,omitempty"`

	// inactive
	Inactive bool `json:"Inactive,omitempty"`

	// individual constituent
	IndividualConstituent *Entity `json:"IndividualConstituent,omitempty"`

	// individual constituent name
	IndividualConstituentName string `json:"IndividualConstituentName,omitempty"`

	// individual constituent sort name
	IndividualConstituentSortName string `json:"IndividualConstituentSortName,omitempty"`

	// is allowed to transact
	IsAllowedToTransact bool `json:"IsAllowedToTransact,omitempty"`

	// is included in search results
	IsIncludedInSearchResults bool `json:"IsIncludedInSearchResults,omitempty"`

	// name indicator
	NameIndicator int32 `json:"NameIndicator,omitempty"`

	// note
	Note string `json:"Note,omitempty"`

	// primary indicator
	PrimaryIndicator bool `json:"PrimaryIndicator,omitempty"`

	// salary
	Salary float64 `json:"Salary,omitempty"`

	// salutation Id
	SalutationID int32 `json:"SalutationId,omitempty"`

	// start date
	// Format: date-time
	StartDate *strfmt.DateTime `json:"StartDate,omitempty"`

	// title
	Title string `json:"Title,omitempty"`

	// updated by
	UpdatedBy string `json:"UpdatedBy,omitempty"`

	// updated date time
	// Format: date-time
	UpdatedDateTime *strfmt.DateTime `json:"UpdatedDateTime,omitempty"`
}

// Validate validates this affiliation
func (m *Affiliation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAffiliationType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroupConstituent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIndividualConstituent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedDateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Affiliation) validateAffiliationType(formats strfmt.Registry) error {
	if swag.IsZero(m.AffiliationType) { // not required
		return nil
	}

	if m.AffiliationType != nil {
		if err := m.AffiliationType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("AffiliationType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("AffiliationType")
			}
			return err
		}
	}

	return nil
}

func (m *Affiliation) validateCreatedDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("CreatedDateTime", "body", "date-time", m.CreatedDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Affiliation) validateEndDate(formats strfmt.Registry) error {
	if swag.IsZero(m.EndDate) { // not required
		return nil
	}

	if err := validate.FormatOf("EndDate", "body", "date-time", m.EndDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Affiliation) validateGroupConstituent(formats strfmt.Registry) error {
	if swag.IsZero(m.GroupConstituent) { // not required
		return nil
	}

	if m.GroupConstituent != nil {
		if err := m.GroupConstituent.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("GroupConstituent")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("GroupConstituent")
			}
			return err
		}
	}

	return nil
}

func (m *Affiliation) validateIndividualConstituent(formats strfmt.Registry) error {
	if swag.IsZero(m.IndividualConstituent) { // not required
		return nil
	}

	if m.IndividualConstituent != nil {
		if err := m.IndividualConstituent.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("IndividualConstituent")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("IndividualConstituent")
			}
			return err
		}
	}

	return nil
}

func (m *Affiliation) validateStartDate(formats strfmt.Registry) error {
	if swag.IsZero(m.StartDate) { // not required
		return nil
	}

	if err := validate.FormatOf("StartDate", "body", "date-time", m.StartDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Affiliation) validateUpdatedDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdatedDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("UpdatedDateTime", "body", "date-time", m.UpdatedDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this affiliation based on the context it is used
func (m *Affiliation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAffiliationType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGroupConstituent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIndividualConstituent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Affiliation) contextValidateAffiliationType(ctx context.Context, formats strfmt.Registry) error {

	if m.AffiliationType != nil {

		if swag.IsZero(m.AffiliationType) { // not required
			return nil
		}

		if err := m.AffiliationType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("AffiliationType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("AffiliationType")
			}
			return err
		}
	}

	return nil
}

func (m *Affiliation) contextValidateGroupConstituent(ctx context.Context, formats strfmt.Registry) error {

	if m.GroupConstituent != nil {

		if swag.IsZero(m.GroupConstituent) { // not required
			return nil
		}

		if err := m.GroupConstituent.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("GroupConstituent")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("GroupConstituent")
			}
			return err
		}
	}

	return nil
}

func (m *Affiliation) contextValidateIndividualConstituent(ctx context.Context, formats strfmt.Registry) error {

	if m.IndividualConstituent != nil {

		if swag.IsZero(m.IndividualConstituent) { // not required
			return nil
		}

		if err := m.IndividualConstituent.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("IndividualConstituent")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("IndividualConstituent")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Affiliation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Affiliation) UnmarshalBinary(b []byte) error {
	var res Affiliation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
