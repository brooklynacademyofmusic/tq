// Generates the tq commands that integrate with the tessitura swagger API code generated by the code in ./swagger
//go:generate go run . cmd
//go:generate go run . test
//go:generate go run . docs

package main

import (
	"errors"
	"os"
	"reflect"
	"slices"
	"strings"
	"text/template"

	"github.com/skysyzygy/tq/client"
	"github.com/spf13/cobra"
)

var generateCmd = &cobra.Command{
	Short: "Tool to generate code and documentation for tq",
}

var docsCmd = &cobra.Command{
	Use:   "docs",
	Short: "Generate mkdocs documentation",
	Run: func(cmd *cobra.Command, args []string) {
		generate("docs.tmpl", "../doc/docs", ".md")
	},
}
var cmdCmd = &cobra.Command{
	Use:   "cmd",
	Short: "Generate go code in /cmd",
	Run: func(cmd *cobra.Command, args []string) {
		generate("commands.go.tmpl", "../cmd", ".go")
	},
}
var testCmd = &cobra.Command{
	Use:   "test",
	Short: "Generate go tests in /cmd",
	Run: func(cmd *cobra.Command, args []string) {
		generate("commands_test.go.tmpl", "../cmd", "_test.go")
	},
}

func main() {
	err := generateCmd.Execute()
	if err != nil {
		panic(err)
	}
}

func init() {
	generateCmd.AddCommand(docsCmd, testCmd, cmdCmd)
}

func generate(templateFile string, outDir string, outSuffix string) {
	// add a new function to the template engine
	funcs := template.FuncMap{"join": strings.Join}
	templ, err := template.New("commands").Funcs(funcs).ParseFiles(templateFile)
	if err != nil {
		panic(err)
	}

	for _, op := range []string{"Get", "Put", "Post"} {
		templateData := make(map[string]any)
		templateData["commands"] = getCommandData()
		templateData["op"] = op
		file, err := os.Create(outDir + "/" + strings.ToLower(op) + outSuffix)
		if err := errors.Join(templ.ExecuteTemplate(file, templateFile, templateData), err); err != nil {
			panic(err)
		}
	}
}

// Build data about entities that can be used with `operation` (i.e. "Get", "Post", "Put")
func getCommandData() (data map[string]map[string][]command) {
	data = make(map[string]map[string][]command)
	client := client.New(nil, nil)
	clientType := reflect.TypeOf(*client)
	for i := 0; i < clientType.NumField(); i++ {
		doer := clientType.Field(i)
		// Group commands by the thing they operate on
		for i := 0; i < doer.Type.NumMethod(); i++ {
			cmd := newCommand(doer.Type.Method(i))
			if cmd.Thing != "" {
				if data[cmd.Thing] == nil {
					data[cmd.Thing] = make(map[string][]command)
				}
				data[cmd.Thing][doer.Name] = append(
					data[cmd.Thing][doer.Name], cmd)
			}
		}

		// Ensure that the first command is the one without a variant
		for _, commands := range data {
			slices.SortFunc(commands[doer.Name], func(a command, b command) int {
				return strings.Compare(a.Variant, b.Variant)
			})
		}
	}
	return
}
