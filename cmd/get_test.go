// Code generated by tq/generator; DO NOT EDIT.

package cmd

import (
	"testing"
    "regexp"
    "strings"

	"github.com/stretchr/testify/assert"
    "github.com/skysyzygy/tq/tq"
    "github.com/spf13/viper"
)


func Test_Get_AccountTypes__cmd(t *testing.T) {
        command := Get_AccountTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AccountTypes_All_cmd(t *testing.T) {
        command := Get_AccountTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AccountTypes_Summaries_cmd(t *testing.T) {
        command := Get_AccountTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Accounts__cmd(t *testing.T) {
        command := Get_Accounts_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Accounts_All_cmd(t *testing.T) {
        command := Get_Accounts_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ActionTypes__cmd(t *testing.T) {
        command := Get_ActionTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ActionTypes_All_cmd(t *testing.T) {
        command := Get_ActionTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ActionTypes_Summaries_cmd(t *testing.T) {
        command := Get_ActionTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Actions__cmd(t *testing.T) {
        command := Get_Actions_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Actions_All_cmd(t *testing.T) {
        command := Get_Actions_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ActivityCategories__cmd(t *testing.T) {
        command := Get_ActivityCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ActivityCategories_All_cmd(t *testing.T) {
        command := Get_ActivityCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ActivityCategories_Summaries_cmd(t *testing.T) {
        command := Get_ActivityCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ActivityTypes__cmd(t *testing.T) {
        command := Get_ActivityTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ActivityTypes_All_cmd(t *testing.T) {
        command := Get_ActivityTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ActivityTypes_Summaries_cmd(t *testing.T) {
        command := Get_ActivityTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AddressTypes__cmd(t *testing.T) {
        command := Get_AddressTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AddressTypes_All_cmd(t *testing.T) {
        command := Get_AddressTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AddressTypes_Summaries_cmd(t *testing.T) {
        command := Get_AddressTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Addresses__cmd(t *testing.T) {
        command := Get_Addresses_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Addresses_All_cmd(t *testing.T) {
        command := Get_Addresses_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AffiliationTypes__cmd(t *testing.T) {
        command := Get_AffiliationTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AffiliationTypes_All_cmd(t *testing.T) {
        command := Get_AffiliationTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AffiliationTypes_Summaries_cmd(t *testing.T) {
        command := Get_AffiliationTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Affiliations__cmd(t *testing.T) {
        command := Get_Affiliations_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Affiliations_All_cmd(t *testing.T) {
        command := Get_Affiliations_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AliasTypes__cmd(t *testing.T) {
        command := Get_AliasTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AliasTypes_All_cmd(t *testing.T) {
        command := Get_AliasTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AliasTypes_Summaries_cmd(t *testing.T) {
        command := Get_AliasTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Aliases__cmd(t *testing.T) {
        command := Get_Aliases_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Aliases_All_cmd(t *testing.T) {
        command := Get_Aliases_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AnalyticsCubes__cmd(t *testing.T) {
        command := Get_AnalyticsCubes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AnalyticsCubes_All_cmd(t *testing.T) {
        command := Get_AnalyticsCubes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AnalyticsReports__cmd(t *testing.T) {
        command := Get_AnalyticsReports_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AnalyticsReports_All_cmd(t *testing.T) {
        command := Get_AnalyticsReports_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AppScreenTexts__cmd(t *testing.T) {
        command := Get_AppScreenTexts_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AppScreenTexts_All_cmd(t *testing.T) {
        command := Get_AppScreenTexts_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AppScreenTexts_Summaries_cmd(t *testing.T) {
        command := Get_AppScreenTexts_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AppealCategories__cmd(t *testing.T) {
        command := Get_AppealCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AppealCategories_All_cmd(t *testing.T) {
        command := Get_AppealCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AppealCategories_Summaries_cmd(t *testing.T) {
        command := Get_AppealCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Appeals__cmd(t *testing.T) {
        command := Get_Appeals_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Appeals_Summaries_cmd(t *testing.T) {
        command := Get_Appeals_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ApplicationObjects_All_cmd(t *testing.T) {
        command := Get_ApplicationObjects_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Artists__cmd(t *testing.T) {
        command := Get_Artists_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Artists_All_cmd(t *testing.T) {
        command := Get_Artists_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AssetTypes__cmd(t *testing.T) {
        command := Get_AssetTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AssetTypes_All_cmd(t *testing.T) {
        command := Get_AssetTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AssetTypes_Summaries_cmd(t *testing.T) {
        command := Get_AssetTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Assets__cmd(t *testing.T) {
        command := Get_Assets_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Assets_All_cmd(t *testing.T) {
        command := Get_Assets_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AssociationTypes__cmd(t *testing.T) {
        command := Get_AssociationTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AssociationTypes_All_cmd(t *testing.T) {
        command := Get_AssociationTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AssociationTypes_Summaries_cmd(t *testing.T) {
        command := Get_AssociationTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Associations__cmd(t *testing.T) {
        command := Get_Associations_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Associations_All_cmd(t *testing.T) {
        command := Get_Associations_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AttendanceHistory_All_cmd(t *testing.T) {
        command := Get_AttendanceHistory_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Attributes__cmd(t *testing.T) {
        command := Get_Attributes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Attributes_All_cmd(t *testing.T) {
        command := Get_Attributes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AuditLogs__cmd(t *testing.T) {
        command := Get_AuditLogs_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AuditLogs_All_cmd(t *testing.T) {
        command := Get_AuditLogs_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_AuditLogs_Details_cmd(t *testing.T) {
        command := Get_AuditLogs_cmd
        use := command.Use

        flag := command.Flag("Details")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Authenticate_WindowsAuthentication_cmd(t *testing.T) {
        command := Get_Authenticate_cmd
        use := command.Use

        flag := command.Flag("WindowsAuthentication")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BatchMaintenance__cmd(t *testing.T) {
        command := Get_BatchMaintenance_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BatchMaintenance_Active_cmd(t *testing.T) {
        command := Get_BatchMaintenance_cmd
        use := command.Use

        flag := command.Flag("Active")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BatchTypeGroups__cmd(t *testing.T) {
        command := Get_BatchTypeGroups_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BatchTypeGroups_All_cmd(t *testing.T) {
        command := Get_BatchTypeGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BatchTypeGroups_Summaries_cmd(t *testing.T) {
        command := Get_BatchTypeGroups_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BatchTypeUserGroup_All_cmd(t *testing.T) {
        command := Get_BatchTypeUserGroup_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BatchTypes__cmd(t *testing.T) {
        command := Get_BatchTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BatchTypes_All_cmd(t *testing.T) {
        command := Get_BatchTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BatchTypes_Summaries_cmd(t *testing.T) {
        command := Get_BatchTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BillingSchedules__cmd(t *testing.T) {
        command := Get_BillingSchedules_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BillingSchedules_All_cmd(t *testing.T) {
        command := Get_BillingSchedules_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BillingSchedules_Summaries_cmd(t *testing.T) {
        command := Get_BillingSchedules_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BillingTypes__cmd(t *testing.T) {
        command := Get_BillingTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BillingTypes_All_cmd(t *testing.T) {
        command := Get_BillingTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BillingTypes_Summaries_cmd(t *testing.T) {
        command := Get_BillingTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BookingCategories__cmd(t *testing.T) {
        command := Get_BookingCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BookingCategories_All_cmd(t *testing.T) {
        command := Get_BookingCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BookingCategories_Summaries_cmd(t *testing.T) {
        command := Get_BookingCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BookingTemplates__cmd(t *testing.T) {
        command := Get_BookingTemplates_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BookingTemplates_Summaries_cmd(t *testing.T) {
        command := Get_BookingTemplates_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Bookings__cmd(t *testing.T) {
        command := Get_Bookings_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Bookings_AllDocumentSummaries_cmd(t *testing.T) {
        command := Get_Bookings_cmd
        use := command.Use

        flag := command.Flag("AllDocumentSummaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Bookings_AllDocuments_cmd(t *testing.T) {
        command := Get_Bookings_cmd
        use := command.Use

        flag := command.Flag("AllDocuments")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Bookings_Document_cmd(t *testing.T) {
        command := Get_Bookings_cmd
        use := command.Use

        flag := command.Flag("Document")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Bookings_Summary_cmd(t *testing.T) {
        command := Get_Bookings_cmd
        use := command.Use

        flag := command.Flag("Summary")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BulkCopySets__cmd(t *testing.T) {
        command := Get_BulkCopySets_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BulkCopySets_All_cmd(t *testing.T) {
        command := Get_BulkCopySets_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BulkCopySets_DayForCopy_cmd(t *testing.T) {
        command := Get_BulkCopySets_cmd
        use := command.Use

        flag := command.Flag("DayForCopy")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BulkCopySets_Summaries_cmd(t *testing.T) {
        command := Get_BulkCopySets_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BulkDailyCopyExclusions__cmd(t *testing.T) {
        command := Get_BulkDailyCopyExclusions_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BulkDailyCopyExclusions_All_cmd(t *testing.T) {
        command := Get_BulkDailyCopyExclusions_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BusinessUnits__cmd(t *testing.T) {
        command := Get_BusinessUnits_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BusinessUnits_All_cmd(t *testing.T) {
        command := Get_BusinessUnits_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_BusinessUnits_Summaries_cmd(t *testing.T) {
        command := Get_BusinessUnits_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Cache_Init_cmd(t *testing.T) {
        command := Get_Cache_cmd
        use := command.Use

        flag := command.Flag("Init")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CampaignDesignations__cmd(t *testing.T) {
        command := Get_CampaignDesignations_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CampaignDesignations_All_cmd(t *testing.T) {
        command := Get_CampaignDesignations_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CampaignFunds__cmd(t *testing.T) {
        command := Get_CampaignFunds_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CampaignFunds_All_cmd(t *testing.T) {
        command := Get_CampaignFunds_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Campaigns__cmd(t *testing.T) {
        command := Get_Campaigns_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Campaigns_Summaries_cmd(t *testing.T) {
        command := Get_Campaigns_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CardReaderTypes__cmd(t *testing.T) {
        command := Get_CardReaderTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CardReaderTypes_All_cmd(t *testing.T) {
        command := Get_CardReaderTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CardReaderTypes_Summaries_cmd(t *testing.T) {
        command := Get_CardReaderTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Cart__cmd(t *testing.T) {
        command := Get_Cart_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Cart_CartProperties_cmd(t *testing.T) {
        command := Get_Cart_cmd
        use := command.Use

        flag := command.Flag("CartProperties")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Cart_Messages_cmd(t *testing.T) {
        command := Get_Cart_cmd
        use := command.Use

        flag := command.Flag("Messages")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Cart_ReceiptString_cmd(t *testing.T) {
        command := Get_Cart_cmd
        use := command.Use

        flag := command.Flag("ReceiptString")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Cart_Summary_cmd(t *testing.T) {
        command := Get_Cart_cmd
        use := command.Use

        flag := command.Flag("Summary")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Colors__cmd(t *testing.T) {
        command := Get_Colors_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Colors_All_cmd(t *testing.T) {
        command := Get_Colors_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Colors_Summaries_cmd(t *testing.T) {
        command := Get_Colors_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Composers__cmd(t *testing.T) {
        command := Get_Composers_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Composers_All_cmd(t *testing.T) {
        command := Get_Composers_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Composers_Summaries_cmd(t *testing.T) {
        command := Get_Composers_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Constituencies__cmd(t *testing.T) {
        command := Get_Constituencies_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Constituencies_All_cmd(t *testing.T) {
        command := Get_Constituencies_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituencyTypes__cmd(t *testing.T) {
        command := Get_ConstituencyTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituencyTypes_All_cmd(t *testing.T) {
        command := Get_ConstituencyTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituencyTypes_Summaries_cmd(t *testing.T) {
        command := Get_ConstituencyTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituentContributions_All_cmd(t *testing.T) {
        command := Get_ConstituentContributions_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituentDocuments__cmd(t *testing.T) {
        command := Get_ConstituentDocuments_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituentDocuments_All_cmd(t *testing.T) {
        command := Get_ConstituentDocuments_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituentDocuments_AllSummary_cmd(t *testing.T) {
        command := Get_ConstituentDocuments_cmd
        use := command.Use

        flag := command.Flag("AllSummary")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituentGroups__cmd(t *testing.T) {
        command := Get_ConstituentGroups_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituentGroups_All_cmd(t *testing.T) {
        command := Get_ConstituentGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituentGroups_Summaries_cmd(t *testing.T) {
        command := Get_ConstituentGroups_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituentInactives__cmd(t *testing.T) {
        command := Get_ConstituentInactives_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituentInactives_All_cmd(t *testing.T) {
        command := Get_ConstituentInactives_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituentInactives_Summaries_cmd(t *testing.T) {
        command := Get_ConstituentInactives_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituentProtectionTypes__cmd(t *testing.T) {
        command := Get_ConstituentProtectionTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituentProtectionTypes_All_cmd(t *testing.T) {
        command := Get_ConstituentProtectionTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituentProtectionTypes_Summaries_cmd(t *testing.T) {
        command := Get_ConstituentProtectionTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituentTypeAffiliates__cmd(t *testing.T) {
        command := Get_ConstituentTypeAffiliates_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituentTypeAffiliates_All_cmd(t *testing.T) {
        command := Get_ConstituentTypeAffiliates_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituentTypeAffiliates_Summaries_cmd(t *testing.T) {
        command := Get_ConstituentTypeAffiliates_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituentTypes__cmd(t *testing.T) {
        command := Get_ConstituentTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituentTypes_All_cmd(t *testing.T) {
        command := Get_ConstituentTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ConstituentTypes_Summaries_cmd(t *testing.T) {
        command := Get_ConstituentTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Constituents__cmd(t *testing.T) {
        command := Get_Constituents_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Constituents_Constituent_cmd(t *testing.T) {
        command := Get_Constituents_cmd
        use := command.Use

        flag := command.Flag("Constituent")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Constituents_ConstituentDevelopmentInfo_cmd(t *testing.T) {
        command := Get_Constituents_cmd
        use := command.Use

        flag := command.Flag("ConstituentDevelopmentInfo")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Constituents_ConstituentSnapshot_cmd(t *testing.T) {
        command := Get_Constituents_cmd
        use := command.Use

        flag := command.Flag("ConstituentSnapshot")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Constituents_Constituents_cmd(t *testing.T) {
        command := Get_Constituents_cmd
        use := command.Use

        flag := command.Flag("Constituents")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Constituents_DefaultHeader_cmd(t *testing.T) {
        command := Get_Constituents_cmd
        use := command.Use

        flag := command.Flag("DefaultHeader")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Constituents_FlexHeader_cmd(t *testing.T) {
        command := Get_Constituents_cmd
        use := command.Use

        flag := command.Flag("FlexHeader")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Constituents_Header_cmd(t *testing.T) {
        command := Get_Constituents_cmd
        use := command.Use

        flag := command.Flag("Header")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Constituents_PrimaryHousehold_cmd(t *testing.T) {
        command := Get_Constituents_cmd
        use := command.Use

        flag := command.Flag("PrimaryHousehold")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Constituents_Search_cmd(t *testing.T) {
        command := Get_Constituents_cmd
        use := command.Use

        flag := command.Flag("Search")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPermissionCategories__cmd(t *testing.T) {
        command := Get_ContactPermissionCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPermissionCategories_All_cmd(t *testing.T) {
        command := Get_ContactPermissionCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPermissionCategories_Summaries_cmd(t *testing.T) {
        command := Get_ContactPermissionCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPermissionTypes__cmd(t *testing.T) {
        command := Get_ContactPermissionTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPermissionTypes_All_cmd(t *testing.T) {
        command := Get_ContactPermissionTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPermissionTypes_ForProductionSeasons_cmd(t *testing.T) {
        command := Get_ContactPermissionTypes_cmd
        use := command.Use

        flag := command.Flag("ForProductionSeasons")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPermissionTypes_Summaries_cmd(t *testing.T) {
        command := Get_ContactPermissionTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPermissions__cmd(t *testing.T) {
        command := Get_ContactPermissions_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPermissions_All_cmd(t *testing.T) {
        command := Get_ContactPermissions_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPointCategories__cmd(t *testing.T) {
        command := Get_ContactPointCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPointCategories_All_cmd(t *testing.T) {
        command := Get_ContactPointCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPointCategories_Summaries_cmd(t *testing.T) {
        command := Get_ContactPointCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPointCategoryPurposes__cmd(t *testing.T) {
        command := Get_ContactPointCategoryPurposes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPointCategoryPurposes_All_cmd(t *testing.T) {
        command := Get_ContactPointCategoryPurposes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPointCategoryPurposes_Summaries_cmd(t *testing.T) {
        command := Get_ContactPointCategoryPurposes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPointPurposeCategories__cmd(t *testing.T) {
        command := Get_ContactPointPurposeCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPointPurposeCategories_All_cmd(t *testing.T) {
        command := Get_ContactPointPurposeCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPointPurposeCategories_Summaries_cmd(t *testing.T) {
        command := Get_ContactPointPurposeCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPointPurposeMaps__cmd(t *testing.T) {
        command := Get_ContactPointPurposeMaps_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPointPurposeMaps_All_cmd(t *testing.T) {
        command := Get_ContactPointPurposeMaps_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPointPurposes__cmd(t *testing.T) {
        command := Get_ContactPointPurposes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPointPurposes_All_cmd(t *testing.T) {
        command := Get_ContactPointPurposes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPointPurposes_Summaries_cmd(t *testing.T) {
        command := Get_ContactPointPurposes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactPoints_All_cmd(t *testing.T) {
        command := Get_ContactPoints_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactTypes__cmd(t *testing.T) {
        command := Get_ContactTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactTypes_All_cmd(t *testing.T) {
        command := Get_ContactTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContactTypes_Summaries_cmd(t *testing.T) {
        command := Get_ContactTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContextInformation__cmd(t *testing.T) {
        command := Get_ContextInformation_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContributionDesignations__cmd(t *testing.T) {
        command := Get_ContributionDesignations_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContributionDesignations_All_cmd(t *testing.T) {
        command := Get_ContributionDesignations_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContributionDesignations_Summaries_cmd(t *testing.T) {
        command := Get_ContributionDesignations_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContributionImportSets__cmd(t *testing.T) {
        command := Get_ContributionImportSets_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContributionImportSets_All_cmd(t *testing.T) {
        command := Get_ContributionImportSets_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ContributionImportSets_Summaries_cmd(t *testing.T) {
        command := Get_ContributionImportSets_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ControlGroupUserGroups__cmd(t *testing.T) {
        command := Get_ControlGroupUserGroups_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ControlGroupUserGroups_All_cmd(t *testing.T) {
        command := Get_ControlGroupUserGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ControlGroupUserGroups_Summaries_cmd(t *testing.T) {
        command := Get_ControlGroupUserGroups_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ControlGroups__cmd(t *testing.T) {
        command := Get_ControlGroups_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ControlGroups_All_cmd(t *testing.T) {
        command := Get_ControlGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ControlGroups_Summaries_cmd(t *testing.T) {
        command := Get_ControlGroups_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CoreIdentity_Token_cmd(t *testing.T) {
        command := Get_CoreIdentity_cmd
        use := command.Use

        flag := command.Flag("Token")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Countries__cmd(t *testing.T) {
        command := Get_Countries_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Countries_All_cmd(t *testing.T) {
        command := Get_Countries_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Countries_Summaries_cmd(t *testing.T) {
        command := Get_Countries_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CrediteeTypes__cmd(t *testing.T) {
        command := Get_CrediteeTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CrediteeTypes_All_cmd(t *testing.T) {
        command := Get_CrediteeTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CrediteeTypes_Summaries_cmd(t *testing.T) {
        command := Get_CrediteeTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Credits_Credits_cmd(t *testing.T) {
        command := Get_Credits_cmd
        use := command.Use

        flag := command.Flag("Credits")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CriterionOperators__cmd(t *testing.T) {
        command := Get_CriterionOperators_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CriterionOperators_All_cmd(t *testing.T) {
        command := Get_CriterionOperators_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CriterionOperators_Summaries_cmd(t *testing.T) {
        command := Get_CriterionOperators_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CumulativeGivingReceipts__cmd(t *testing.T) {
        command := Get_CumulativeGivingReceipts_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CumulativeGivingReceipts_All_cmd(t *testing.T) {
        command := Get_CumulativeGivingReceipts_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CumulativeGivingReceipts_ForSession_cmd(t *testing.T) {
        command := Get_CumulativeGivingReceipts_cmd
        use := command.Use

        flag := command.Flag("ForSession")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CurrencyTypes__cmd(t *testing.T) {
        command := Get_CurrencyTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CurrencyTypes_All_cmd(t *testing.T) {
        command := Get_CurrencyTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CurrencyTypes_Summaries_cmd(t *testing.T) {
        command := Get_CurrencyTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Custom__cmd(t *testing.T) {
        command := Get_Custom_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Custom_All_cmd(t *testing.T) {
        command := Get_Custom_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Custom_Metadata_cmd(t *testing.T) {
        command := Get_Custom_cmd
        use := command.Use

        flag := command.Flag("Metadata")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CustomDefaultCategories__cmd(t *testing.T) {
        command := Get_CustomDefaultCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CustomDefaultCategories_All_cmd(t *testing.T) {
        command := Get_CustomDefaultCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CustomDefaultCategories_Summaries_cmd(t *testing.T) {
        command := Get_CustomDefaultCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CustomDefaults__cmd(t *testing.T) {
        command := Get_CustomDefaults_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CustomDefaults_All_cmd(t *testing.T) {
        command := Get_CustomDefaults_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_CustomDefaults_Summaries_cmd(t *testing.T) {
        command := Get_CustomDefaults_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_DeliveryMethods__cmd(t *testing.T) {
        command := Get_DeliveryMethods_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_DeliveryMethods_All_cmd(t *testing.T) {
        command := Get_DeliveryMethods_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_DeliveryMethods_Summaries_cmd(t *testing.T) {
        command := Get_DeliveryMethods_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_DesignationCodes__cmd(t *testing.T) {
        command := Get_DesignationCodes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_DesignationCodes_All_cmd(t *testing.T) {
        command := Get_DesignationCodes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_DesignationCodes_Summaries_cmd(t *testing.T) {
        command := Get_DesignationCodes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Designs__cmd(t *testing.T) {
        command := Get_Designs_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Designs_All_cmd(t *testing.T) {
        command := Get_Designs_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Designs_Summaries_cmd(t *testing.T) {
        command := Get_Designs_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Diagnostics_EncryptionKeyCheck_cmd(t *testing.T) {
        command := Get_Diagnostics_cmd
        use := command.Use

        flag := command.Flag("EncryptionKeyCheck")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Diagnostics_SeatServerStatus_cmd(t *testing.T) {
        command := Get_Diagnostics_cmd
        use := command.Use

        flag := command.Flag("SeatServerStatus")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Diagnostics_Status_cmd(t *testing.T) {
        command := Get_Diagnostics_cmd
        use := command.Use

        flag := command.Flag("Status")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Diagnostics_StatusReport_cmd(t *testing.T) {
        command := Get_Diagnostics_cmd
        use := command.Use

        flag := command.Flag("StatusReport")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_DirectDebitAccountTypes__cmd(t *testing.T) {
        command := Get_DirectDebitAccountTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_DirectDebitAccountTypes_All_cmd(t *testing.T) {
        command := Get_DirectDebitAccountTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_DirectDebitAccountTypes_Summaries_cmd(t *testing.T) {
        command := Get_DirectDebitAccountTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_DiscountTypes__cmd(t *testing.T) {
        command := Get_DiscountTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_DiscountTypes_All_cmd(t *testing.T) {
        command := Get_DiscountTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_DiscountTypes_Summaries_cmd(t *testing.T) {
        command := Get_DiscountTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Divisions_All_cmd(t *testing.T) {
        command := Get_Divisions_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Divisions_ForDivision_cmd(t *testing.T) {
        command := Get_Divisions_cmd
        use := command.Use

        flag := command.Flag("ForDivision")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_DocumentCategories__cmd(t *testing.T) {
        command := Get_DocumentCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_DocumentCategories_All_cmd(t *testing.T) {
        command := Get_DocumentCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_DocumentCategories_Summaries_cmd(t *testing.T) {
        command := Get_DocumentCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Documents__cmd(t *testing.T) {
        command := Get_Documents_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Documents_All_cmd(t *testing.T) {
        command := Get_Documents_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Documents_AllSummary_cmd(t *testing.T) {
        command := Get_Documents_cmd
        use := command.Use

        flag := command.Flag("AllSummary")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Documents_Settings_cmd(t *testing.T) {
        command := Get_Documents_cmd
        use := command.Use

        flag := command.Flag("Settings")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_DonationLevels__cmd(t *testing.T) {
        command := Get_DonationLevels_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_DonationLevels_All_cmd(t *testing.T) {
        command := Get_DonationLevels_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_DonationLevels_Summaries_cmd(t *testing.T) {
        command := Get_DonationLevels_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_EMV_AllLanes_cmd(t *testing.T) {
        command := Get_EMV_cmd
        use := command.Use

        flag := command.Flag("AllLanes")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_EMV_ConnectionStatus_cmd(t *testing.T) {
        command := Get_EMV_cmd
        use := command.Use

        flag := command.Flag("ConnectionStatus")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_EMV_ConnectionStatusHistory_cmd(t *testing.T) {
        command := Get_EMV_cmd
        use := command.Use

        flag := command.Flag("ConnectionStatusHistory")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_EMV_IdleMessage_cmd(t *testing.T) {
        command := Get_EMV_cmd
        use := command.Use

        flag := command.Flag("IdleMessage")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_EMV_Lane_cmd(t *testing.T) {
        command := Get_EMV_cmd
        use := command.Use

        flag := command.Flag("Lane")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ElectronicAddressTypes__cmd(t *testing.T) {
        command := Get_ElectronicAddressTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ElectronicAddressTypes_All_cmd(t *testing.T) {
        command := Get_ElectronicAddressTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ElectronicAddressTypes_Summaries_cmd(t *testing.T) {
        command := Get_ElectronicAddressTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ElectronicAddresses__cmd(t *testing.T) {
        command := Get_ElectronicAddresses_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ElectronicAddresses_All_cmd(t *testing.T) {
        command := Get_ElectronicAddresses_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ElectronicAddresses_IsAttachedToLogin_cmd(t *testing.T) {
        command := Get_ElectronicAddresses_cmd
        use := command.Use

        flag := command.Flag("IsAttachedToLogin")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_EmailProfiles__cmd(t *testing.T) {
        command := Get_EmailProfiles_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_EmailProfiles_All_cmd(t *testing.T) {
        command := Get_EmailProfiles_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_EmailProfiles_Summaries_cmd(t *testing.T) {
        command := Get_EmailProfiles_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_EmarketIndicators__cmd(t *testing.T) {
        command := Get_EmarketIndicators_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_EmarketIndicators_All_cmd(t *testing.T) {
        command := Get_EmarketIndicators_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_EmarketIndicators_Summaries_cmd(t *testing.T) {
        command := Get_EmarketIndicators_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Eras__cmd(t *testing.T) {
        command := Get_Eras_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Eras_All_cmd(t *testing.T) {
        command := Get_Eras_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Eras_Summaries_cmd(t *testing.T) {
        command := Get_Eras_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_EventControl_All_cmd(t *testing.T) {
        command := Get_EventControl_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Facilities__cmd(t *testing.T) {
        command := Get_Facilities_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Facilities_All_cmd(t *testing.T) {
        command := Get_Facilities_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Facilities_Screens_cmd(t *testing.T) {
        command := Get_Facilities_cmd
        use := command.Use

        flag := command.Flag("Screens")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Facilities_Summaries_cmd(t *testing.T) {
        command := Get_Facilities_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Fees__cmd(t *testing.T) {
        command := Get_Fees_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Fees_All_cmd(t *testing.T) {
        command := Get_Fees_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Fees_Summaries_cmd(t *testing.T) {
        command := Get_Fees_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_FinanceContributions__cmd(t *testing.T) {
        command := Get_FinanceContributions_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_FinanceContributions_All_cmd(t *testing.T) {
        command := Get_FinanceContributions_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Formats__cmd(t *testing.T) {
        command := Get_Formats_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Formats_All_cmd(t *testing.T) {
        command := Get_Formats_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Formats_Summaries_cmd(t *testing.T) {
        command := Get_Formats_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Funds__cmd(t *testing.T) {
        command := Get_Funds_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Funds_Summaries_cmd(t *testing.T) {
        command := Get_Funds_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GLAccounts__cmd(t *testing.T) {
        command := Get_GLAccounts_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GLAccounts_All_cmd(t *testing.T) {
        command := Get_GLAccounts_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GLAccounts_Summaries_cmd(t *testing.T) {
        command := Get_GLAccounts_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Genders__cmd(t *testing.T) {
        command := Get_Genders_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Genders_All_cmd(t *testing.T) {
        command := Get_Genders_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Genders_Summaries_cmd(t *testing.T) {
        command := Get_Genders_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidContactMethods__cmd(t *testing.T) {
        command := Get_GiftAidContactMethods_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidContactMethods_All_cmd(t *testing.T) {
        command := Get_GiftAidContactMethods_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidContactMethods_Summaries_cmd(t *testing.T) {
        command := Get_GiftAidContactMethods_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidDeclarations__cmd(t *testing.T) {
        command := Get_GiftAidDeclarations_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidDeclarations_All_cmd(t *testing.T) {
        command := Get_GiftAidDeclarations_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidDocumentStatuses__cmd(t *testing.T) {
        command := Get_GiftAidDocumentStatuses_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidDocumentStatuses_All_cmd(t *testing.T) {
        command := Get_GiftAidDocumentStatuses_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidDocumentStatuses_Summaries_cmd(t *testing.T) {
        command := Get_GiftAidDocumentStatuses_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidIneligibleReasons__cmd(t *testing.T) {
        command := Get_GiftAidIneligibleReasons_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidIneligibleReasons_All_cmd(t *testing.T) {
        command := Get_GiftAidIneligibleReasons_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidIneligibleReasons_Summaries_cmd(t *testing.T) {
        command := Get_GiftAidIneligibleReasons_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidRates__cmd(t *testing.T) {
        command := Get_GiftAidRates_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidRates_All_cmd(t *testing.T) {
        command := Get_GiftAidRates_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidRates_Summaries_cmd(t *testing.T) {
        command := Get_GiftAidRates_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidStatuses__cmd(t *testing.T) {
        command := Get_GiftAidStatuses_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidStatuses_All_cmd(t *testing.T) {
        command := Get_GiftAidStatuses_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidStatuses_Summaries_cmd(t *testing.T) {
        command := Get_GiftAidStatuses_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidTypes__cmd(t *testing.T) {
        command := Get_GiftAidTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidTypes_All_cmd(t *testing.T) {
        command := Get_GiftAidTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftAidTypes_Summaries_cmd(t *testing.T) {
        command := Get_GiftAidTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_GiftCertificates__cmd(t *testing.T) {
        command := Get_GiftCertificates_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_HoldCodeCategories__cmd(t *testing.T) {
        command := Get_HoldCodeCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_HoldCodeCategories_All_cmd(t *testing.T) {
        command := Get_HoldCodeCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_HoldCodeCategories_Summaries_cmd(t *testing.T) {
        command := Get_HoldCodeCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_HoldCodeUserGroups__cmd(t *testing.T) {
        command := Get_HoldCodeUserGroups_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_HoldCodeUserGroups_All_cmd(t *testing.T) {
        command := Get_HoldCodeUserGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_HoldCodeUserGroups_Summaries_cmd(t *testing.T) {
        command := Get_HoldCodeUserGroups_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_HoldCodeUserGroups_Summary_cmd(t *testing.T) {
        command := Get_HoldCodeUserGroups_cmd
        use := command.Use

        flag := command.Flag("Summary")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_HoldCodes__cmd(t *testing.T) {
        command := Get_HoldCodes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_HoldCodes_All_cmd(t *testing.T) {
        command := Get_HoldCodes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_InactiveReasons__cmd(t *testing.T) {
        command := Get_InactiveReasons_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_InactiveReasons_All_cmd(t *testing.T) {
        command := Get_InactiveReasons_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_InactiveReasons_Summaries_cmd(t *testing.T) {
        command := Get_InactiveReasons_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_IntegrationDefaults__cmd(t *testing.T) {
        command := Get_IntegrationDefaults_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_IntegrationDefaults_All_cmd(t *testing.T) {
        command := Get_IntegrationDefaults_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_IntegrationDefaults_Summaries_cmd(t *testing.T) {
        command := Get_IntegrationDefaults_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Integrations__cmd(t *testing.T) {
        command := Get_Integrations_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Integrations_All_cmd(t *testing.T) {
        command := Get_Integrations_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Integrations_Summaries_cmd(t *testing.T) {
        command := Get_Integrations_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_InterestCategories__cmd(t *testing.T) {
        command := Get_InterestCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_InterestCategories_All_cmd(t *testing.T) {
        command := Get_InterestCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_InterestCategories_Summaries_cmd(t *testing.T) {
        command := Get_InterestCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_InterestTypes__cmd(t *testing.T) {
        command := Get_InterestTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_InterestTypes_All_cmd(t *testing.T) {
        command := Get_InterestTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_InterestTypes_Summaries_cmd(t *testing.T) {
        command := Get_InterestTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Interests__cmd(t *testing.T) {
        command := Get_Interests_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Interests_All_cmd(t *testing.T) {
        command := Get_Interests_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Internal__cmd(t *testing.T) {
        command := Get_Internal_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Internal_All_cmd(t *testing.T) {
        command := Get_Internal_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Internal_ConstituentMiniSnapshot_cmd(t *testing.T) {
        command := Get_Internal_cmd
        use := command.Use

        flag := command.Flag("ConstituentMiniSnapshot")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_InventoryContactPermissionTypes__cmd(t *testing.T) {
        command := Get_InventoryContactPermissionTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_InventoryContactPermissionTypes_All_cmd(t *testing.T) {
        command := Get_InventoryContactPermissionTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_InventoryWebContents__cmd(t *testing.T) {
        command := Get_InventoryWebContents_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_InventoryWebContents_All_cmd(t *testing.T) {
        command := Get_InventoryWebContents_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_InventoryWebContents_AllSummaries_cmd(t *testing.T) {
        command := Get_InventoryWebContents_cmd
        use := command.Use

        flag := command.Flag("AllSummaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_InvoiceBilling_Status_cmd(t *testing.T) {
        command := Get_InvoiceBilling_cmd
        use := command.Use

        flag := command.Flag("Status")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Issues__cmd(t *testing.T) {
        command := Get_Issues_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Issues_All_cmd(t *testing.T) {
        command := Get_Issues_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_KeywordCategories__cmd(t *testing.T) {
        command := Get_KeywordCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_KeywordCategories_All_cmd(t *testing.T) {
        command := Get_KeywordCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_KeywordCategories_Summaries_cmd(t *testing.T) {
        command := Get_KeywordCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Keywords__cmd(t *testing.T) {
        command := Get_Keywords_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Keywords_All_cmd(t *testing.T) {
        command := Get_Keywords_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Keywords_DataFor_cmd(t *testing.T) {
        command := Get_Keywords_cmd
        use := command.Use

        flag := command.Flag("DataFor")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Keywords_Summaries_cmd(t *testing.T) {
        command := Get_Keywords_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Languages__cmd(t *testing.T) {
        command := Get_Languages_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Languages_All_cmd(t *testing.T) {
        command := Get_Languages_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Languages_Summaries_cmd(t *testing.T) {
        command := Get_Languages_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ListCategories__cmd(t *testing.T) {
        command := Get_ListCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ListCategories_All_cmd(t *testing.T) {
        command := Get_ListCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ListCategories_Summaries_cmd(t *testing.T) {
        command := Get_ListCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Lists__cmd(t *testing.T) {
        command := Get_Lists_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Lists_Contents_cmd(t *testing.T) {
        command := Get_Lists_cmd
        use := command.Use

        flag := command.Flag("Contents")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Lists_ContentsDetail_cmd(t *testing.T) {
        command := Get_Lists_cmd
        use := command.Use

        flag := command.Flag("ContentsDetail")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Lists_ListCriterionMatchReasons_cmd(t *testing.T) {
        command := Get_Lists_cmd
        use := command.Use

        flag := command.Flag("ListCriterionMatchReasons")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Lists_Summaries_cmd(t *testing.T) {
        command := Get_Lists_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_LoginTypes__cmd(t *testing.T) {
        command := Get_LoginTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_LoginTypes_All_cmd(t *testing.T) {
        command := Get_LoginTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_LoginTypes_Summaries_cmd(t *testing.T) {
        command := Get_LoginTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MachineSettings__cmd(t *testing.T) {
        command := Get_MachineSettings_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MachineSettings_All_cmd(t *testing.T) {
        command := Get_MachineSettings_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MachineSettings_Summaries_cmd(t *testing.T) {
        command := Get_MachineSettings_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MailIndicators__cmd(t *testing.T) {
        command := Get_MailIndicators_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MailIndicators_All_cmd(t *testing.T) {
        command := Get_MailIndicators_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MailIndicators_Summaries_cmd(t *testing.T) {
        command := Get_MailIndicators_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MediaTypes__cmd(t *testing.T) {
        command := Get_MediaTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MediaTypes_All_cmd(t *testing.T) {
        command := Get_MediaTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MediaTypes_Summaries_cmd(t *testing.T) {
        command := Get_MediaTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MembershipLevelCategories__cmd(t *testing.T) {
        command := Get_MembershipLevelCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MembershipLevelCategories_All_cmd(t *testing.T) {
        command := Get_MembershipLevelCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MembershipLevelCategories_Summaries_cmd(t *testing.T) {
        command := Get_MembershipLevelCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MembershipLevels__cmd(t *testing.T) {
        command := Get_MembershipLevels_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MembershipLevels_All_cmd(t *testing.T) {
        command := Get_MembershipLevels_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MembershipLevels_Summaries_cmd(t *testing.T) {
        command := Get_MembershipLevels_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MembershipOrganizations__cmd(t *testing.T) {
        command := Get_MembershipOrganizations_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MembershipOrganizations_All_cmd(t *testing.T) {
        command := Get_MembershipOrganizations_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MembershipOrganizations_Summaries_cmd(t *testing.T) {
        command := Get_MembershipOrganizations_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MembershipStandings__cmd(t *testing.T) {
        command := Get_MembershipStandings_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MembershipStandings_All_cmd(t *testing.T) {
        command := Get_MembershipStandings_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MembershipStandings_Summaries_cmd(t *testing.T) {
        command := Get_MembershipStandings_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Memberships_All_cmd(t *testing.T) {
        command := Get_Memberships_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_MerchantReferences_Reference_cmd(t *testing.T) {
        command := Get_MerchantReferences_cmd
        use := command.Use

        flag := command.Flag("Reference")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Merchants_Merchants_cmd(t *testing.T) {
        command := Get_Merchants_cmd
        use := command.Use

        flag := command.Flag("Merchants")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ModeOfSaleCategories__cmd(t *testing.T) {
        command := Get_ModeOfSaleCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ModeOfSaleCategories_All_cmd(t *testing.T) {
        command := Get_ModeOfSaleCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ModeOfSaleOffers__cmd(t *testing.T) {
        command := Get_ModeOfSaleOffers_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ModeOfSaleOffers_All_cmd(t *testing.T) {
        command := Get_ModeOfSaleOffers_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ModeOfSalePriceTypes__cmd(t *testing.T) {
        command := Get_ModeOfSalePriceTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ModeOfSalePriceTypes_All_cmd(t *testing.T) {
        command := Get_ModeOfSalePriceTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ModeOfSaleSurveyQuestions__cmd(t *testing.T) {
        command := Get_ModeOfSaleSurveyQuestions_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ModeOfSaleSurveyQuestions_All_cmd(t *testing.T) {
        command := Get_ModeOfSaleSurveyQuestions_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ModeOfSaleUserGroups__cmd(t *testing.T) {
        command := Get_ModeOfSaleUserGroups_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ModeOfSaleUserGroups_All_cmd(t *testing.T) {
        command := Get_ModeOfSaleUserGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ModesOfSale__cmd(t *testing.T) {
        command := Get_ModesOfSale_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ModesOfSale_All_cmd(t *testing.T) {
        command := Get_ModesOfSale_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ModesOfSale_Summaries_cmd(t *testing.T) {
        command := Get_ModesOfSale_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_NScanAccessAreas__cmd(t *testing.T) {
        command := Get_NScanAccessAreas_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_NScanAccessAreas_All_cmd(t *testing.T) {
        command := Get_NScanAccessAreas_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_NScanAccessAreas_Summaries_cmd(t *testing.T) {
        command := Get_NScanAccessAreas_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_NameStatuses__cmd(t *testing.T) {
        command := Get_NameStatuses_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_NameStatuses_All_cmd(t *testing.T) {
        command := Get_NameStatuses_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_NameStatuses_Summaries_cmd(t *testing.T) {
        command := Get_NameStatuses_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ObjectPermissions__cmd(t *testing.T) {
        command := Get_ObjectPermissions_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ObjectPermissions_All_cmd(t *testing.T) {
        command := Get_ObjectPermissions_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ObjectPermissions_Summaries_cmd(t *testing.T) {
        command := Get_ObjectPermissions_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_OrderBilling_Reprint_cmd(t *testing.T) {
        command := Get_OrderBilling_cmd
        use := command.Use

        flag := command.Flag("Reprint")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_OrderBilling_Status_cmd(t *testing.T) {
        command := Get_OrderBilling_cmd
        use := command.Use

        flag := command.Flag("Status")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_OrderCategories__cmd(t *testing.T) {
        command := Get_OrderCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_OrderCategories_All_cmd(t *testing.T) {
        command := Get_OrderCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_OrderCategories_Summaries_cmd(t *testing.T) {
        command := Get_OrderCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Orders_ProductsView_cmd(t *testing.T) {
        command := Get_Orders_cmd
        use := command.Use

        flag := command.Flag("ProductsView")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Organizations__cmd(t *testing.T) {
        command := Get_Organizations_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Organizations_All_cmd(t *testing.T) {
        command := Get_Organizations_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Organizations_Summaries_cmd(t *testing.T) {
        command := Get_Organizations_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_OriginalSources__cmd(t *testing.T) {
        command := Get_OriginalSources_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_OriginalSources_All_cmd(t *testing.T) {
        command := Get_OriginalSources_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_OriginalSources_Summaries_cmd(t *testing.T) {
        command := Get_OriginalSources_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Origins__cmd(t *testing.T) {
        command := Get_Origins_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Origins_All_cmd(t *testing.T) {
        command := Get_Origins_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Origins_Summaries_cmd(t *testing.T) {
        command := Get_Origins_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_OutputSets__cmd(t *testing.T) {
        command := Get_OutputSets_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_OutputSets_Summaries_cmd(t *testing.T) {
        command := Get_OutputSets_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PackageHistory_All_cmd(t *testing.T) {
        command := Get_PackageHistory_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PackagePriceTypes__cmd(t *testing.T) {
        command := Get_PackagePriceTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PackagePriceTypes_All_cmd(t *testing.T) {
        command := Get_PackagePriceTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PackageTypes__cmd(t *testing.T) {
        command := Get_PackageTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PackageTypes_All_cmd(t *testing.T) {
        command := Get_PackageTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PackageTypes_Summaries_cmd(t *testing.T) {
        command := Get_PackageTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PackageWebContents__cmd(t *testing.T) {
        command := Get_PackageWebContents_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PackageWebContents_All_cmd(t *testing.T) {
        command := Get_PackageWebContents_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PackageWebContents_AllSummaries_cmd(t *testing.T) {
        command := Get_PackageWebContents_cmd
        use := command.Use

        flag := command.Flag("AllSummaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Packages__cmd(t *testing.T) {
        command := Get_Packages_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Packages_All_cmd(t *testing.T) {
        command := Get_Packages_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Packages_PackageDetail_cmd(t *testing.T) {
        command := Get_Packages_cmd
        use := command.Use

        flag := command.Flag("PackageDetail")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Packages_PerformanceGroupDetails_cmd(t *testing.T) {
        command := Get_Packages_cmd
        use := command.Use

        flag := command.Flag("PerformanceGroupDetails")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Packages_Prices_cmd(t *testing.T) {
        command := Get_Packages_cmd
        use := command.Use

        flag := command.Flag("Prices")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Packages_SeatFees_cmd(t *testing.T) {
        command := Get_Packages_cmd
        use := command.Use

        flag := command.Flag("SeatFees")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Packages_SeatSummaries_cmd(t *testing.T) {
        command := Get_Packages_cmd
        use := command.Use

        flag := command.Flag("SeatSummaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Packages_Seats_cmd(t *testing.T) {
        command := Get_Packages_cmd
        use := command.Use

        flag := command.Flag("Seats")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Packages_Summaries_cmd(t *testing.T) {
        command := Get_Packages_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentGatewayActivities__cmd(t *testing.T) {
        command := Get_PaymentGatewayActivities_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentGatewayActivities_All_cmd(t *testing.T) {
        command := Get_PaymentGatewayActivities_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentGatewayConfiguration_Configuration_cmd(t *testing.T) {
        command := Get_PaymentGatewayConfiguration_cmd
        use := command.Use

        flag := command.Flag("Configuration")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentGatewayNotifications_AllNotificationEvents_cmd(t *testing.T) {
        command := Get_PaymentGatewayNotifications_cmd
        use := command.Use

        flag := command.Flag("AllNotificationEvents")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentGatewayNotifications_Check_cmd(t *testing.T) {
        command := Get_PaymentGatewayNotifications_cmd
        use := command.Use

        flag := command.Flag("Check")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentGatewayNotifications_Notification_cmd(t *testing.T) {
        command := Get_PaymentGatewayNotifications_cmd
        use := command.Use

        flag := command.Flag("Notification")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentGatewayNotifications_NotificationEvent_cmd(t *testing.T) {
        command := Get_PaymentGatewayNotifications_cmd
        use := command.Use

        flag := command.Flag("NotificationEvent")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentGatewayTransactionTypes__cmd(t *testing.T) {
        command := Get_PaymentGatewayTransactionTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentGatewayTransactionTypes_All_cmd(t *testing.T) {
        command := Get_PaymentGatewayTransactionTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentGatewayTransactionTypes_Summaries_cmd(t *testing.T) {
        command := Get_PaymentGatewayTransactionTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentHistory_All_cmd(t *testing.T) {
        command := Get_PaymentHistory_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentMethodGroups__cmd(t *testing.T) {
        command := Get_PaymentMethodGroups_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentMethodGroups_All_cmd(t *testing.T) {
        command := Get_PaymentMethodGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentMethodGroups_Summaries_cmd(t *testing.T) {
        command := Get_PaymentMethodGroups_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentMethodUserGroups__cmd(t *testing.T) {
        command := Get_PaymentMethodUserGroups_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentMethodUserGroups_All_cmd(t *testing.T) {
        command := Get_PaymentMethodUserGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentMethods__cmd(t *testing.T) {
        command := Get_PaymentMethods_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentMethods_All_cmd(t *testing.T) {
        command := Get_PaymentMethods_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentMethods_Check_cmd(t *testing.T) {
        command := Get_PaymentMethods_cmd
        use := command.Use

        flag := command.Flag("Check")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentMethods_TranslateMnemonic_cmd(t *testing.T) {
        command := Get_PaymentMethods_cmd
        use := command.Use

        flag := command.Flag("TranslateMnemonic")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentSignatures__cmd(t *testing.T) {
        command := Get_PaymentSignatures_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentSignatures_All_cmd(t *testing.T) {
        command := Get_PaymentSignatures_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentTypes__cmd(t *testing.T) {
        command := Get_PaymentTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentTypes_All_cmd(t *testing.T) {
        command := Get_PaymentTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PaymentTypes_Summaries_cmd(t *testing.T) {
        command := Get_PaymentTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Payments__cmd(t *testing.T) {
        command := Get_Payments_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Payments_All_cmd(t *testing.T) {
        command := Get_Payments_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Payments_AvailableForRefund_cmd(t *testing.T) {
        command := Get_Payments_cmd
        use := command.Use

        flag := command.Flag("AvailableForRefund")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Payments_OnAccountBalances_cmd(t *testing.T) {
        command := Get_Payments_cmd
        use := command.Use

        flag := command.Flag("OnAccountBalances")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformanceGroups__cmd(t *testing.T) {
        command := Get_PerformanceGroups_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformanceGroups_All_cmd(t *testing.T) {
        command := Get_PerformanceGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformanceGroups_Summaries_cmd(t *testing.T) {
        command := Get_PerformanceGroups_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformancePackageModeOfSales__cmd(t *testing.T) {
        command := Get_PerformancePackageModeOfSales_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformancePackageModeOfSales_All_cmd(t *testing.T) {
        command := Get_PerformancePackageModeOfSales_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformancePriceLayers__cmd(t *testing.T) {
        command := Get_PerformancePriceLayers_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformancePriceLayers_Counts_cmd(t *testing.T) {
        command := Get_PerformancePriceLayers_cmd
        use := command.Use

        flag := command.Flag("Counts")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformancePriceLayers_PriceCount_cmd(t *testing.T) {
        command := Get_PerformancePriceLayers_cmd
        use := command.Use

        flag := command.Flag("PriceCount")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformancePriceTypes__cmd(t *testing.T) {
        command := Get_PerformancePriceTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformancePriceTypes_All_cmd(t *testing.T) {
        command := Get_PerformancePriceTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformancePrices__cmd(t *testing.T) {
        command := Get_PerformancePrices_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformancePrices_All_cmd(t *testing.T) {
        command := Get_PerformancePrices_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformancePrices_AllWithEvents_cmd(t *testing.T) {
        command := Get_PerformancePrices_cmd
        use := command.Use

        flag := command.Flag("AllWithEvents")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformancePrices_Audit_cmd(t *testing.T) {
        command := Get_PerformancePrices_cmd
        use := command.Use

        flag := command.Flag("Audit")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformanceStatuses__cmd(t *testing.T) {
        command := Get_PerformanceStatuses_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformanceStatuses_All_cmd(t *testing.T) {
        command := Get_PerformanceStatuses_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformanceStatuses_Summaries_cmd(t *testing.T) {
        command := Get_PerformanceStatuses_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformanceTypes__cmd(t *testing.T) {
        command := Get_PerformanceTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformanceTypes_All_cmd(t *testing.T) {
        command := Get_PerformanceTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PerformanceTypes_Summaries_cmd(t *testing.T) {
        command := Get_PerformanceTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Performances__cmd(t *testing.T) {
        command := Get_Performances_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Performances_All_cmd(t *testing.T) {
        command := Get_Performances_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Performances_AuditEntries_cmd(t *testing.T) {
        command := Get_Performances_cmd
        use := command.Use

        flag := command.Flag("AuditEntries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Performances_PerformanceZoneAvailabilities_cmd(t *testing.T) {
        command := Get_Performances_cmd
        use := command.Use

        flag := command.Flag("PerformanceZoneAvailabilities")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Performances_PerformanceZoneAvailabilityWithConstituent_cmd(t *testing.T) {
        command := Get_Performances_cmd
        use := command.Use

        flag := command.Flag("PerformanceZoneAvailabilityWithConstituent")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Performances_Prices_cmd(t *testing.T) {
        command := Get_Performances_cmd
        use := command.Use

        flag := command.Flag("Prices")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Performances_SeatFees_cmd(t *testing.T) {
        command := Get_Performances_cmd
        use := command.Use

        flag := command.Flag("SeatFees")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Performances_SeatHoldDetails_cmd(t *testing.T) {
        command := Get_Performances_cmd
        use := command.Use

        flag := command.Flag("SeatHoldDetails")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Performances_SeatSummaries_cmd(t *testing.T) {
        command := Get_Performances_cmd
        use := command.Use

        flag := command.Flag("SeatSummaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Performances_Seats_cmd(t *testing.T) {
        command := Get_Performances_cmd
        use := command.Use

        flag := command.Flag("Seats")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Performances_Summaries_cmd(t *testing.T) {
        command := Get_Performances_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Philanthropy__cmd(t *testing.T) {
        command := Get_Philanthropy_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Philanthropy_All_cmd(t *testing.T) {
        command := Get_Philanthropy_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PhilanthropyTypes__cmd(t *testing.T) {
        command := Get_PhilanthropyTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PhilanthropyTypes_All_cmd(t *testing.T) {
        command := Get_PhilanthropyTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PhilanthropyTypes_Summaries_cmd(t *testing.T) {
        command := Get_PhilanthropyTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PhoneIndicators__cmd(t *testing.T) {
        command := Get_PhoneIndicators_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PhoneIndicators_All_cmd(t *testing.T) {
        command := Get_PhoneIndicators_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PhoneIndicators_Summaries_cmd(t *testing.T) {
        command := Get_PhoneIndicators_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PhoneTypes__cmd(t *testing.T) {
        command := Get_PhoneTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PhoneTypes_All_cmd(t *testing.T) {
        command := Get_PhoneTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PhoneTypes_Summaries_cmd(t *testing.T) {
        command := Get_PhoneTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Phones__cmd(t *testing.T) {
        command := Get_Phones_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Phones_All_cmd(t *testing.T) {
        command := Get_Phones_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PlanPriorities__cmd(t *testing.T) {
        command := Get_PlanPriorities_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PlanPriorities_All_cmd(t *testing.T) {
        command := Get_PlanPriorities_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PlanPriorities_Summaries_cmd(t *testing.T) {
        command := Get_PlanPriorities_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PlanSources__cmd(t *testing.T) {
        command := Get_PlanSources_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PlanSources_All_cmd(t *testing.T) {
        command := Get_PlanSources_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PlanSources_Summaries_cmd(t *testing.T) {
        command := Get_PlanSources_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PlanStatuses__cmd(t *testing.T) {
        command := Get_PlanStatuses_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PlanStatuses_All_cmd(t *testing.T) {
        command := Get_PlanStatuses_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PlanStatuses_Summaries_cmd(t *testing.T) {
        command := Get_PlanStatuses_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PlanTypes__cmd(t *testing.T) {
        command := Get_PlanTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PlanTypes_All_cmd(t *testing.T) {
        command := Get_PlanTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PlanTypes_Summaries_cmd(t *testing.T) {
        command := Get_PlanTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PlanWorkers__cmd(t *testing.T) {
        command := Get_PlanWorkers_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PlanWorkers_All_cmd(t *testing.T) {
        command := Get_PlanWorkers_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Plans__cmd(t *testing.T) {
        command := Get_Plans_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Plans_All_cmd(t *testing.T) {
        command := Get_Plans_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PledgeBilling_Status_cmd(t *testing.T) {
        command := Get_PledgeBilling_cmd
        use := command.Use

        flag := command.Flag("Status")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PortfolioCustomElements__cmd(t *testing.T) {
        command := Get_PortfolioCustomElements_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PortfolioCustomElements_All_cmd(t *testing.T) {
        command := Get_PortfolioCustomElements_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PortfolioCustomElements_Summaries_cmd(t *testing.T) {
        command := Get_PortfolioCustomElements_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Portfolios__cmd(t *testing.T) {
        command := Get_Portfolios_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Portfolios_PortfolioEntry_cmd(t *testing.T) {
        command := Get_Portfolios_cmd
        use := command.Use

        flag := command.Flag("PortfolioEntry")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Prefixes__cmd(t *testing.T) {
        command := Get_Prefixes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Prefixes_All_cmd(t *testing.T) {
        command := Get_Prefixes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Prefixes_Summaries_cmd(t *testing.T) {
        command := Get_Prefixes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Premieres__cmd(t *testing.T) {
        command := Get_Premieres_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Premieres_All_cmd(t *testing.T) {
        command := Get_Premieres_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Premieres_Summaries_cmd(t *testing.T) {
        command := Get_Premieres_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceCategories__cmd(t *testing.T) {
        command := Get_PriceCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceCategories_All_cmd(t *testing.T) {
        command := Get_PriceCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceCategories_Summaries_cmd(t *testing.T) {
        command := Get_PriceCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceEvents__cmd(t *testing.T) {
        command := Get_PriceEvents_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceEvents_All_cmd(t *testing.T) {
        command := Get_PriceEvents_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceEvents_Dates_cmd(t *testing.T) {
        command := Get_PriceEvents_cmd
        use := command.Use

        flag := command.Flag("Dates")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceLayerTypes__cmd(t *testing.T) {
        command := Get_PriceLayerTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceLayerTypes_All_cmd(t *testing.T) {
        command := Get_PriceLayerTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceLayerTypes_Summaries_cmd(t *testing.T) {
        command := Get_PriceLayerTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTemplates__cmd(t *testing.T) {
        command := Get_PriceTemplates_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTemplates_All_cmd(t *testing.T) {
        command := Get_PriceTemplates_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTemplates_Summaries_cmd(t *testing.T) {
        command := Get_PriceTemplates_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTypeCategories__cmd(t *testing.T) {
        command := Get_PriceTypeCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTypeCategories_All_cmd(t *testing.T) {
        command := Get_PriceTypeCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTypeCategories_Summaries_cmd(t *testing.T) {
        command := Get_PriceTypeCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTypeGroups__cmd(t *testing.T) {
        command := Get_PriceTypeGroups_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTypeGroups_All_cmd(t *testing.T) {
        command := Get_PriceTypeGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTypeGroups_Summaries_cmd(t *testing.T) {
        command := Get_PriceTypeGroups_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTypeReasons__cmd(t *testing.T) {
        command := Get_PriceTypeReasons_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTypeReasons_All_cmd(t *testing.T) {
        command := Get_PriceTypeReasons_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTypeReasons_Summaries_cmd(t *testing.T) {
        command := Get_PriceTypeReasons_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTypeUserGroups__cmd(t *testing.T) {
        command := Get_PriceTypeUserGroups_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTypeUserGroups_All_cmd(t *testing.T) {
        command := Get_PriceTypeUserGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTypes__cmd(t *testing.T) {
        command := Get_PriceTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTypes_All_cmd(t *testing.T) {
        command := Get_PriceTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTypes_Reasons_cmd(t *testing.T) {
        command := Get_PriceTypes_cmd
        use := command.Use

        flag := command.Flag("Reasons")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTypes_Summaries_cmd(t *testing.T) {
        command := Get_PriceTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTypes_ValidPriceTypes_cmd(t *testing.T) {
        command := Get_PriceTypes_cmd
        use := command.Use

        flag := command.Flag("ValidPriceTypes")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PriceTypes_ValidZones_cmd(t *testing.T) {
        command := Get_PriceTypes_cmd
        use := command.Use

        flag := command.Flag("ValidZones")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PricingRuleCategories__cmd(t *testing.T) {
        command := Get_PricingRuleCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PricingRuleCategories_All_cmd(t *testing.T) {
        command := Get_PricingRuleCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PricingRuleCategories_Summaries_cmd(t *testing.T) {
        command := Get_PricingRuleCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PricingRuleMessageTypes__cmd(t *testing.T) {
        command := Get_PricingRuleMessageTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PricingRuleMessageTypes_All_cmd(t *testing.T) {
        command := Get_PricingRuleMessageTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PricingRuleMessageTypes_Summaries_cmd(t *testing.T) {
        command := Get_PricingRuleMessageTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PricingRuleSets__cmd(t *testing.T) {
        command := Get_PricingRuleSets_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PricingRuleSets_All_cmd(t *testing.T) {
        command := Get_PricingRuleSets_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PricingRuleSets_Summaries_cmd(t *testing.T) {
        command := Get_PricingRuleSets_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PricingRuleTypes__cmd(t *testing.T) {
        command := Get_PricingRuleTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PricingRuleTypes_All_cmd(t *testing.T) {
        command := Get_PricingRuleTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PricingRuleTypes_Summaries_cmd(t *testing.T) {
        command := Get_PricingRuleTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PricingRules__cmd(t *testing.T) {
        command := Get_PricingRules_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PricingRules_All_cmd(t *testing.T) {
        command := Get_PricingRules_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_PricingRules_AllSummary_cmd(t *testing.T) {
        command := Get_PricingRules_cmd
        use := command.Use

        flag := command.Flag("AllSummary")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Printers__cmd(t *testing.T) {
        command := Get_Printers_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Printers_All_cmd(t *testing.T) {
        command := Get_Printers_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Printers_Summaries_cmd(t *testing.T) {
        command := Get_Printers_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ProductKeywords_Keywords_cmd(t *testing.T) {
        command := Get_ProductKeywords_cmd
        use := command.Use

        flag := command.Flag("Keywords")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ProductionSeasonMembershipOrganizations__cmd(t *testing.T) {
        command := Get_ProductionSeasonMembershipOrganizations_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ProductionSeasonMembershipOrganizations_All_cmd(t *testing.T) {
        command := Get_ProductionSeasonMembershipOrganizations_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ProductionSeasonMembershipOrganizations_Summaries_cmd(t *testing.T) {
        command := Get_ProductionSeasonMembershipOrganizations_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ProductionSeasons__cmd(t *testing.T) {
        command := Get_ProductionSeasons_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ProductionSeasons_All_cmd(t *testing.T) {
        command := Get_ProductionSeasons_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ProductionSeasons_Summaries_cmd(t *testing.T) {
        command := Get_ProductionSeasons_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Productions__cmd(t *testing.T) {
        command := Get_Productions_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Productions_All_cmd(t *testing.T) {
        command := Get_Productions_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Productions_Summaries_cmd(t *testing.T) {
        command := Get_Productions_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ProgramListings__cmd(t *testing.T) {
        command := Get_ProgramListings_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ProgramListings_All_cmd(t *testing.T) {
        command := Get_ProgramListings_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Programs__cmd(t *testing.T) {
        command := Get_Programs_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Programs_All_cmd(t *testing.T) {
        command := Get_Programs_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Programs_Summaries_cmd(t *testing.T) {
        command := Get_Programs_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Pronouns__cmd(t *testing.T) {
        command := Get_Pronouns_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Pronouns_All_cmd(t *testing.T) {
        command := Get_Pronouns_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Pronouns_Summaries_cmd(t *testing.T) {
        command := Get_Pronouns_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_QualificationCategories__cmd(t *testing.T) {
        command := Get_QualificationCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_QualificationCategories_All_cmd(t *testing.T) {
        command := Get_QualificationCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_QualificationCategories_Summaries_cmd(t *testing.T) {
        command := Get_QualificationCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Qualifications__cmd(t *testing.T) {
        command := Get_Qualifications_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Qualifications_All_cmd(t *testing.T) {
        command := Get_Qualifications_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Qualifications_Summaries_cmd(t *testing.T) {
        command := Get_Qualifications_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_QueryElementFilters__cmd(t *testing.T) {
        command := Get_QueryElementFilters_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_QueryElementFilters_All_cmd(t *testing.T) {
        command := Get_QueryElementFilters_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_QueryElementFilters_DataFor_cmd(t *testing.T) {
        command := Get_QueryElementFilters_cmd
        use := command.Use

        flag := command.Flag("DataFor")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_QueryElementFilters_Summaries_cmd(t *testing.T) {
        command := Get_QueryElementFilters_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_QueryElementGroups__cmd(t *testing.T) {
        command := Get_QueryElementGroups_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_QueryElementGroups_All_cmd(t *testing.T) {
        command := Get_QueryElementGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_QueryElements__cmd(t *testing.T) {
        command := Get_QueryElements_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_QueryElements_All_cmd(t *testing.T) {
        command := Get_QueryElements_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_QueryElements_Summaries_cmd(t *testing.T) {
        command := Get_QueryElements_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_RankTypes__cmd(t *testing.T) {
        command := Get_RankTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_RankTypes_All_cmd(t *testing.T) {
        command := Get_RankTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_RankTypes_Summaries_cmd(t *testing.T) {
        command := Get_RankTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Rankings__cmd(t *testing.T) {
        command := Get_Rankings_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Rankings_All_cmd(t *testing.T) {
        command := Get_Rankings_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReceiptSettings__cmd(t *testing.T) {
        command := Get_ReceiptSettings_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReceiptSettings_All_cmd(t *testing.T) {
        command := Get_ReceiptSettings_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReceiptSettings_Summaries_cmd(t *testing.T) {
        command := Get_ReceiptSettings_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReferenceColumns_All_cmd(t *testing.T) {
        command := Get_ReferenceColumns_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReferenceColumns_Summaries_cmd(t *testing.T) {
        command := Get_ReferenceColumns_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReferenceTableUserGroups__cmd(t *testing.T) {
        command := Get_ReferenceTableUserGroups_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReferenceTableUserGroups_All_cmd(t *testing.T) {
        command := Get_ReferenceTableUserGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReferenceTableUserGroups_Summaries_cmd(t *testing.T) {
        command := Get_ReferenceTableUserGroups_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReferenceTables__cmd(t *testing.T) {
        command := Get_ReferenceTables_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReferenceTables_All_cmd(t *testing.T) {
        command := Get_ReferenceTables_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReferenceTables_Summaries_cmd(t *testing.T) {
        command := Get_ReferenceTables_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_RelationshipCategories__cmd(t *testing.T) {
        command := Get_RelationshipCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_RelationshipCategories_All_cmd(t *testing.T) {
        command := Get_RelationshipCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_RelationshipCategories_Summaries_cmd(t *testing.T) {
        command := Get_RelationshipCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Relationships_All_cmd(t *testing.T) {
        command := Get_Relationships_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReportRequests__cmd(t *testing.T) {
        command := Get_ReportRequests_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReportRequests_All_cmd(t *testing.T) {
        command := Get_ReportRequests_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReportRequests_AllExpired_cmd(t *testing.T) {
        command := Get_ReportRequests_cmd
        use := command.Use

        flag := command.Flag("AllExpired")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReportRequests_Queued_cmd(t *testing.T) {
        command := Get_ReportRequests_cmd
        use := command.Use

        flag := command.Flag("Queued")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReportSchedules__cmd(t *testing.T) {
        command := Get_ReportSchedules_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReportSchedules_All_cmd(t *testing.T) {
        command := Get_ReportSchedules_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReportUserGroups__cmd(t *testing.T) {
        command := Get_ReportUserGroups_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReportUserGroups_All_cmd(t *testing.T) {
        command := Get_ReportUserGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ReportUserGroups_Summaries_cmd(t *testing.T) {
        command := Get_ReportUserGroups_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Reports__cmd(t *testing.T) {
        command := Get_Reports_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Reports_All_cmd(t *testing.T) {
        command := Get_Reports_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Reports_CustomData_cmd(t *testing.T) {
        command := Get_Reports_cmd
        use := command.Use

        flag := command.Flag("CustomData")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Reports_ReportCategories_cmd(t *testing.T) {
        command := Get_Reports_cmd
        use := command.Use

        flag := command.Flag("ReportCategories")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Reports_ReportDefaults_cmd(t *testing.T) {
        command := Get_Reports_cmd
        use := command.Use

        flag := command.Flag("ReportDefaults")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Reports_ReportParameters_cmd(t *testing.T) {
        command := Get_Reports_cmd
        use := command.Use

        flag := command.Flag("ReportParameters")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Research__cmd(t *testing.T) {
        command := Get_Research_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Research_All_cmd(t *testing.T) {
        command := Get_Research_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ResearchTypes__cmd(t *testing.T) {
        command := Get_ResearchTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ResearchTypes_All_cmd(t *testing.T) {
        command := Get_ResearchTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ResearchTypes_Summaries_cmd(t *testing.T) {
        command := Get_ResearchTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ResourceCategories__cmd(t *testing.T) {
        command := Get_ResourceCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ResourceCategories_All_cmd(t *testing.T) {
        command := Get_ResourceCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ResourceCategories_Summaries_cmd(t *testing.T) {
        command := Get_ResourceCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ResourceSchedules__cmd(t *testing.T) {
        command := Get_ResourceSchedules_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ResourceSchedules_All_cmd(t *testing.T) {
        command := Get_ResourceSchedules_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ResourceTypes__cmd(t *testing.T) {
        command := Get_ResourceTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ResourceTypes_All_cmd(t *testing.T) {
        command := Get_ResourceTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ResourceTypes_Summaries_cmd(t *testing.T) {
        command := Get_ResourceTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Resources__cmd(t *testing.T) {
        command := Get_Resources_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Resources_All_cmd(t *testing.T) {
        command := Get_Resources_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Resources_Details_cmd(t *testing.T) {
        command := Get_Resources_cmd
        use := command.Use

        flag := command.Flag("Details")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Resources_HasUsages_cmd(t *testing.T) {
        command := Get_Resources_cmd
        use := command.Use

        flag := command.Flag("HasUsages")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Resources_Summaries_cmd(t *testing.T) {
        command := Get_Resources_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SalesChannels__cmd(t *testing.T) {
        command := Get_SalesChannels_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SalesChannels_All_cmd(t *testing.T) {
        command := Get_SalesChannels_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SalesChannels_Summaries_cmd(t *testing.T) {
        command := Get_SalesChannels_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SalesLayoutButtonTypes__cmd(t *testing.T) {
        command := Get_SalesLayoutButtonTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SalesLayoutButtonTypes_All_cmd(t *testing.T) {
        command := Get_SalesLayoutButtonTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SalesLayoutButtonTypes_Summaries_cmd(t *testing.T) {
        command := Get_SalesLayoutButtonTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SalesLayouts__cmd(t *testing.T) {
        command := Get_SalesLayouts_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SalesLayouts_ForSale_cmd(t *testing.T) {
        command := Get_SalesLayouts_cmd
        use := command.Use

        flag := command.Flag("ForSale")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SalesLayouts_Summaries_cmd(t *testing.T) {
        command := Get_SalesLayouts_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SalutationTypes__cmd(t *testing.T) {
        command := Get_SalutationTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SalutationTypes_All_cmd(t *testing.T) {
        command := Get_SalutationTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SalutationTypes_Summaries_cmd(t *testing.T) {
        command := Get_SalutationTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Salutations__cmd(t *testing.T) {
        command := Get_Salutations_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Salutations_All_cmd(t *testing.T) {
        command := Get_Salutations_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Salutations_Generate_cmd(t *testing.T) {
        command := Get_Salutations_cmd
        use := command.Use

        flag := command.Flag("Generate")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SchedulePatternTypes__cmd(t *testing.T) {
        command := Get_SchedulePatternTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SchedulePatternTypes_All_cmd(t *testing.T) {
        command := Get_SchedulePatternTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SchedulePatternTypes_Summaries_cmd(t *testing.T) {
        command := Get_SchedulePatternTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ScheduleTypes__cmd(t *testing.T) {
        command := Get_ScheduleTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ScheduleTypes_All_cmd(t *testing.T) {
        command := Get_ScheduleTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ScheduleTypes_Summaries_cmd(t *testing.T) {
        command := Get_ScheduleTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SeasonTypes__cmd(t *testing.T) {
        command := Get_SeasonTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SeasonTypes_All_cmd(t *testing.T) {
        command := Get_SeasonTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SeasonTypes_Summaries_cmd(t *testing.T) {
        command := Get_SeasonTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Seasons__cmd(t *testing.T) {
        command := Get_Seasons_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Seasons_All_cmd(t *testing.T) {
        command := Get_Seasons_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Seasons_Summaries_cmd(t *testing.T) {
        command := Get_Seasons_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SeatCodes__cmd(t *testing.T) {
        command := Get_SeatCodes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SeatCodes_All_cmd(t *testing.T) {
        command := Get_SeatCodes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SeatCodes_Summaries_cmd(t *testing.T) {
        command := Get_SeatCodes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SeatStatuses__cmd(t *testing.T) {
        command := Get_SeatStatuses_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SeatStatuses_All_cmd(t *testing.T) {
        command := Get_SeatStatuses_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SeatStatuses_Summaries_cmd(t *testing.T) {
        command := Get_SeatStatuses_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Sections__cmd(t *testing.T) {
        command := Get_Sections_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Sections_All_cmd(t *testing.T) {
        command := Get_Sections_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Sections_Summaries_cmd(t *testing.T) {
        command := Get_Sections_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SecurityBatchTypes_All_cmd(t *testing.T) {
        command := Get_SecurityBatchTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SecurityControlGroups_All_cmd(t *testing.T) {
        command := Get_SecurityControlGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SecurityHoldCodes_All_cmd(t *testing.T) {
        command := Get_SecurityHoldCodes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SecurityModesOfSale_All_cmd(t *testing.T) {
        command := Get_SecurityModesOfSale_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SecurityObjectPermissions_All_cmd(t *testing.T) {
        command := Get_SecurityObjectPermissions_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SecurityPaymentMethods_All_cmd(t *testing.T) {
        command := Get_SecurityPaymentMethods_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SecurityPriceTypes_All_cmd(t *testing.T) {
        command := Get_SecurityPriceTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SecurityReferenceTables_All_cmd(t *testing.T) {
        command := Get_SecurityReferenceTables_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SecurityReports_All_cmd(t *testing.T) {
        command := Get_SecurityReports_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SecurityServiceResources_All_cmd(t *testing.T) {
        command := Get_SecurityServiceResources_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SecurityUserGroups_All_cmd(t *testing.T) {
        command := Get_SecurityUserGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SecurityUserGroups_DefaultUserGroup_cmd(t *testing.T) {
        command := Get_SecurityUserGroups_cmd
        use := command.Use

        flag := command.Flag("DefaultUserGroup")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SecurityUserGroups_ManagedGroups_cmd(t *testing.T) {
        command := Get_SecurityUserGroups_cmd
        use := command.Use

        flag := command.Flag("ManagedGroups")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ServiceResourceUserGroups__cmd(t *testing.T) {
        command := Get_ServiceResourceUserGroups_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ServiceResourceUserGroups_All_cmd(t *testing.T) {
        command := Get_ServiceResourceUserGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ServiceResourceUserGroups_Summaries_cmd(t *testing.T) {
        command := Get_ServiceResourceUserGroups_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ServiceResources_All_cmd(t *testing.T) {
        command := Get_ServiceResources_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ServiceResources_Summaries_cmd(t *testing.T) {
        command := Get_ServiceResources_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Session__cmd(t *testing.T) {
        command := Get_Session_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Session_Default_cmd(t *testing.T) {
        command := Get_Session_cmd
        use := command.Use

        flag := command.Flag("Default")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Session_DeliveryMethods_cmd(t *testing.T) {
        command := Get_Session_cmd
        use := command.Use

        flag := command.Flag("DeliveryMethods")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Session_Expiration_cmd(t *testing.T) {
        command := Get_Session_cmd
        use := command.Use

        flag := command.Flag("Expiration")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Session_OnAccountBalances_cmd(t *testing.T) {
        command := Get_Session_cmd
        use := command.Use

        flag := command.Flag("OnAccountBalances")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Session_OrderSearch_cmd(t *testing.T) {
        command := Get_Session_cmd
        use := command.Use

        flag := command.Flag("OrderSearch")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Session_Variable_cmd(t *testing.T) {
        command := Get_Session_cmd
        use := command.Use

        flag := command.Flag("Variable")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Session_Variables_cmd(t *testing.T) {
        command := Get_Session_cmd
        use := command.Use

        flag := command.Flag("Variables")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SourceGroups__cmd(t *testing.T) {
        command := Get_SourceGroups_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SourceGroups_All_cmd(t *testing.T) {
        command := Get_SourceGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SourceGroups_Summaries_cmd(t *testing.T) {
        command := Get_SourceGroups_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Sources__cmd(t *testing.T) {
        command := Get_Sources_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Sources_Summaries_cmd(t *testing.T) {
        command := Get_Sources_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Sources_WebExpiring_cmd(t *testing.T) {
        command := Get_Sources_cmd
        use := command.Use

        flag := command.Flag("WebExpiring")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SpecialActivities__cmd(t *testing.T) {
        command := Get_SpecialActivities_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SpecialActivities_All_cmd(t *testing.T) {
        command := Get_SpecialActivities_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SpecialActivityStatuses__cmd(t *testing.T) {
        command := Get_SpecialActivityStatuses_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SpecialActivityStatuses_All_cmd(t *testing.T) {
        command := Get_SpecialActivityStatuses_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SpecialActivityStatuses_Summaries_cmd(t *testing.T) {
        command := Get_SpecialActivityStatuses_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SpecialActivityTypes__cmd(t *testing.T) {
        command := Get_SpecialActivityTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SpecialActivityTypes_All_cmd(t *testing.T) {
        command := Get_SpecialActivityTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SpecialActivityTypes_Summaries_cmd(t *testing.T) {
        command := Get_SpecialActivityTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_States__cmd(t *testing.T) {
        command := Get_States_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_States_All_cmd(t *testing.T) {
        command := Get_States_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_States_Summaries_cmd(t *testing.T) {
        command := Get_States_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_StepTypes__cmd(t *testing.T) {
        command := Get_StepTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_StepTypes_All_cmd(t *testing.T) {
        command := Get_StepTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_StepTypes_Summaries_cmd(t *testing.T) {
        command := Get_StepTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Steps__cmd(t *testing.T) {
        command := Get_Steps_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Steps_All_cmd(t *testing.T) {
        command := Get_Steps_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Steps_AllDocumentSummaries_cmd(t *testing.T) {
        command := Get_Steps_cmd
        use := command.Use

        flag := command.Flag("AllDocumentSummaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Steps_AllDocuments_cmd(t *testing.T) {
        command := Get_Steps_cmd
        use := command.Use

        flag := command.Flag("AllDocuments")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SubLineItemStatuses__cmd(t *testing.T) {
        command := Get_SubLineItemStatuses_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SubLineItemStatuses_All_cmd(t *testing.T) {
        command := Get_SubLineItemStatuses_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SubLineItemStatuses_Summaries_cmd(t *testing.T) {
        command := Get_SubLineItemStatuses_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SubLineItems_SubLineItemSummaries_cmd(t *testing.T) {
        command := Get_SubLineItems_cmd
        use := command.Use

        flag := command.Flag("SubLineItemSummaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Suffixes__cmd(t *testing.T) {
        command := Get_Suffixes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Suffixes_All_cmd(t *testing.T) {
        command := Get_Suffixes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Suffixes_Summaries_cmd(t *testing.T) {
        command := Get_Suffixes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SurveyQuestions__cmd(t *testing.T) {
        command := Get_SurveyQuestions_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SurveyQuestions_All_cmd(t *testing.T) {
        command := Get_SurveyQuestions_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SurveyQuestions_DataFor_cmd(t *testing.T) {
        command := Get_SurveyQuestions_cmd
        use := command.Use

        flag := command.Flag("DataFor")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SurveyQuestions_Summaries_cmd(t *testing.T) {
        command := Get_SurveyQuestions_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SurveyResponses__cmd(t *testing.T) {
        command := Get_SurveyResponses_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SurveyResponses_All_cmd(t *testing.T) {
        command := Get_SurveyResponses_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SystemDefaults_All_cmd(t *testing.T) {
        command := Get_SystemDefaults_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SystemDefaults_Default_cmd(t *testing.T) {
        command := Get_SystemDefaults_cmd
        use := command.Use

        flag := command.Flag("Default")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_SystemDefaults_Summaries_cmd(t *testing.T) {
        command := Get_SystemDefaults_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_TemplateCategories__cmd(t *testing.T) {
        command := Get_TemplateCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_TemplateCategories_All_cmd(t *testing.T) {
        command := Get_TemplateCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_TemplateCategories_Summaries_cmd(t *testing.T) {
        command := Get_TemplateCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_TemplatePriceTypes__cmd(t *testing.T) {
        command := Get_TemplatePriceTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_TemplatePriceTypes_All_cmd(t *testing.T) {
        command := Get_TemplatePriceTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_TemplatePrices__cmd(t *testing.T) {
        command := Get_TemplatePrices_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_TemplatePrices_All_cmd(t *testing.T) {
        command := Get_TemplatePrices_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_TemplateTypes__cmd(t *testing.T) {
        command := Get_TemplateTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_TemplateTypes_All_cmd(t *testing.T) {
        command := Get_TemplateTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_TemplateTypes_Summaries_cmd(t *testing.T) {
        command := Get_TemplateTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Templates__cmd(t *testing.T) {
        command := Get_Templates_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Templates_All_cmd(t *testing.T) {
        command := Get_Templates_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Templates_Summaries_cmd(t *testing.T) {
        command := Get_Templates_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Theaters__cmd(t *testing.T) {
        command := Get_Theaters_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Theaters_All_cmd(t *testing.T) {
        command := Get_Theaters_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Theaters_Summaries_cmd(t *testing.T) {
        command := Get_Theaters_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_TicketHistory_All_cmd(t *testing.T) {
        command := Get_TicketHistory_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_TimeSlots__cmd(t *testing.T) {
        command := Get_TimeSlots_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_TimeSlots_All_cmd(t *testing.T) {
        command := Get_TimeSlots_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_TimeSlots_Summaries_cmd(t *testing.T) {
        command := Get_TimeSlots_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Titles__cmd(t *testing.T) {
        command := Get_Titles_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Titles_All_cmd(t *testing.T) {
        command := Get_Titles_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Titles_Summaries_cmd(t *testing.T) {
        command := Get_Titles_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_TransactionHistory_All_cmd(t *testing.T) {
        command := Get_TransactionHistory_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_TriPOSCloudConfigurations__cmd(t *testing.T) {
        command := Get_TriPOSCloudConfigurations_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_TriPOSCloudConfigurations_All_cmd(t *testing.T) {
        command := Get_TriPOSCloudConfigurations_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_TriPOSCloudConfigurations_Summaries_cmd(t *testing.T) {
        command := Get_TriPOSCloudConfigurations_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_UpgradeCategories__cmd(t *testing.T) {
        command := Get_UpgradeCategories_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_UpgradeCategories_All_cmd(t *testing.T) {
        command := Get_UpgradeCategories_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_UpgradeCategories_Summaries_cmd(t *testing.T) {
        command := Get_UpgradeCategories_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_UpgradeLogs__cmd(t *testing.T) {
        command := Get_UpgradeLogs_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_UpgradeLogs_All_cmd(t *testing.T) {
        command := Get_UpgradeLogs_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_UserGroups__cmd(t *testing.T) {
        command := Get_UserGroups_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_UserGroups_All_cmd(t *testing.T) {
        command := Get_UserGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_UserGroups_Summaries_cmd(t *testing.T) {
        command := Get_UserGroups_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_UserPreferences__cmd(t *testing.T) {
        command := Get_UserPreferences_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_UserPreferences_All_cmd(t *testing.T) {
        command := Get_UserPreferences_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Users__cmd(t *testing.T) {
        command := Get_Users_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Users_ActiveDirectoryUser_cmd(t *testing.T) {
        command := Get_Users_cmd
        use := command.Use

        flag := command.Flag("ActiveDirectoryUser")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Users_UserInformationForActiveDirectoryUser_cmd(t *testing.T) {
        command := Get_Users_cmd
        use := command.Use

        flag := command.Flag("UserInformationForActiveDirectoryUser")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Users_UsersForUserGroup_cmd(t *testing.T) {
        command := Get_Users_cmd
        use := command.Use

        flag := command.Flag("UsersForUserGroup")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_WebContentTypes__cmd(t *testing.T) {
        command := Get_WebContentTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_WebContentTypes_All_cmd(t *testing.T) {
        command := Get_WebContentTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_WebContentTypes_DataFor_cmd(t *testing.T) {
        command := Get_WebContentTypes_cmd
        use := command.Use

        flag := command.Flag("DataFor")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_WebContentTypes_Summaries_cmd(t *testing.T) {
        command := Get_WebContentTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_WebContents_WebContents_cmd(t *testing.T) {
        command := Get_WebContents_cmd
        use := command.Use

        flag := command.Flag("WebContents")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_WebLogins__cmd(t *testing.T) {
        command := Get_WebLogins_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_WebLogins_All_cmd(t *testing.T) {
        command := Get_WebLogins_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_WebLogins_LoginCredentials_cmd(t *testing.T) {
        command := Get_WebLogins_cmd
        use := command.Use

        flag := command.Flag("LoginCredentials")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_WebLogins_Search_cmd(t *testing.T) {
        command := Get_WebLogins_cmd
        use := command.Use

        flag := command.Flag("Search")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_WorkerQualifications__cmd(t *testing.T) {
        command := Get_WorkerQualifications_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_WorkerQualifications_All_cmd(t *testing.T) {
        command := Get_WorkerQualifications_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_WorkerRoles__cmd(t *testing.T) {
        command := Get_WorkerRoles_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_WorkerRoles_All_cmd(t *testing.T) {
        command := Get_WorkerRoles_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_WorkerRoles_Summaries_cmd(t *testing.T) {
        command := Get_WorkerRoles_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_WorkerTypes__cmd(t *testing.T) {
        command := Get_WorkerTypes_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_WorkerTypes_All_cmd(t *testing.T) {
        command := Get_WorkerTypes_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_WorkerTypes_Summaries_cmd(t *testing.T) {
        command := Get_WorkerTypes_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Workers__cmd(t *testing.T) {
        command := Get_Workers_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Workers_All_cmd(t *testing.T) {
        command := Get_Workers_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Workers_Summaries_cmd(t *testing.T) {
        command := Get_Workers_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ZoneGroups__cmd(t *testing.T) {
        command := Get_ZoneGroups_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ZoneGroups_All_cmd(t *testing.T) {
        command := Get_ZoneGroups_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ZoneGroups_Summaries_cmd(t *testing.T) {
        command := Get_ZoneGroups_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ZoneMaps__cmd(t *testing.T) {
        command := Get_ZoneMaps_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ZoneMaps_All_cmd(t *testing.T) {
        command := Get_ZoneMaps_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_ZoneMaps_Summaries_cmd(t *testing.T) {
        command := Get_ZoneMaps_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Zones__cmd(t *testing.T) {
        command := Get_Zones_cmd
        use := command.Use

        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Zones_All_cmd(t *testing.T) {
        command := Get_Zones_cmd
        use := command.Use

        flag := command.Flag("All")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}

func Test_Get_Zones_Summaries_cmd(t *testing.T) {
        command := Get_Zones_cmd
        use := command.Use

        flag := command.Flag("Summaries")
        if flag != nil {
            flag.Value.Set("true")
            defer flag.Value.Set("false")
            use = flag.Usage
        }
        input := regexp.MustCompile(`\{.+\}$`).FindString(
                            strings.ReplaceAll(use,",...",""))

        out, err := tq.CaptureOutput(func(){
            viper.Set("login",authString)
            // PreRun: tqInit
            if err := command.PreRunE(command, nil); err != nil {
                panic(err)
            }
            //Use: {{ print $key " " $command.Usage 
            if err := command.RunE(command, []string{input}); err != nil {
                _tq.Log.Error(err.Error())
            }
        })
    
        assert.Empty(t, string(err))
        // Note need to test output better
        assert.NotEmpty(t, string(out))
        
}
